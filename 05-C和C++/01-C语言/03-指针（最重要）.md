
# 1. 什么是指针？

![[Pasted image 20251003080314.png]]

上图能够很清晰表示什么是指针，指针本质上就是存储变量对应地址信息。

```c
#include <stdio.h>

int main()
{
    int a = 10;
    // 定义一个指针
    int *ptr = &a;
    int ptrVal = *ptr;
    int ptrSize = sizeof(ptr);
    printf("当前a的值为%d，a的地址为:%p, 指针指向的值为:%d\n", a, ptr, ptrVal);
    printf("指针所占字节数:%d\n", ptrSize);
    // 指向指针的指针
    int **ptr2 = &ptr;
    printf("指向指针的指针地址:%p, 指向最终的数据为: %d\n", ptr2, **ptr2);
    return 0;
}
```

你会发现有一级指针也有二级指针，也就是指向指针的指针，同时还有三级指针，在实际开发中极其罕见，所以实际工作中别用三级指针，找到更好的方案来做。

# 2. 指针的大小

指针的大小取决于环境，如果是32位系统，那么指针占据4个字节；如果是64位系统，那么指针就占据8个字节。

```c
#include <stdio.h>

int main() {
    int *ptr1;
    char *ptr2;
    
    // Finding size using sizeof()
    printf("%zu\n", sizeof(ptr1));  // 8
    printf("%zu", sizeof(ptr2));    // 8
    
    return 0;
}
```

# 3. 指针的特殊类型

## 3.1 NULL Pointer

```c
#include <stdio.h>

int main()
{
    int *ptr = NULL;
    printf("ptr地址: %p\n", ptr);
    return 0;
}
```

> [!danger]
> 对于NULL指针，不能直接解构获取值，会报错，所以应该先判断指针是否为NULL
> 在C语言中一个指针地址是0x0 ，那么它就是空指针

## 3.2 Void Pointer

```c
#include <stdio.h>

int main()
{
    void *ptr;
    int a = 20;
    ptr = &a;

    printf("地址的值%d\n", *(int *)ptr);
    return 0;
}
```

在C语言中`void *ptr`代表的是通用指针，可以指向任何值，如果需要解构其中的值，需要进行强制转换到具体的指针类型才可以。

## 3.3 Wild Pointer

就是只有定义，但是没有初始化的指针，它指向的是一个未知的垃圾值

```c
#include <stdio.h>

int main() {
    // Wild Pointer
    int *ptr;
    return 0;
}
```

在实际开发中要完全避免Wild pointer，没有任何好处。 
```c
int *ptr = NULL; // 安全，访问 NULL 会崩溃但可检测
if (ptr) *ptr = 42; // 检查非 NULL
```

修复的话就是用
```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    int *ptr = NULL; // 初始化为 NULL
    if (ptr == NULL) {
        printf("Pointer is NULL, cannot access\n");
    } else {
        *ptr = 42;
    }

    int *ptr2 = malloc(sizeof(int));
    if (ptr2) {
        *ptr2 = 100;
        free(ptr2);
        ptr2 = NULL; // ❗️❗️❗️ 释放后置空
    }
    if (ptr2) *ptr2 = 200; // 安全检查
    return 0;
}
```

关于野指针，有一个很经典的案例

```c
int *f(void)
{
    int x = 10;
    return (&x);
}
```
## 3.4 Dangling Pointer

指的是在free释放内存后，这个指针就是`dangling pointer`， 需要指向NULL来解决

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int* ptr = (int*)malloc(sizeof(int));

    // After below free call, ptr becomes a dangling pointer
    free(ptr);
    printf("Memory freed\n");

    // removing Dangling Pointer
    ptr = NULL;

    return 0;
}
```

# 4. 指针的运算符有哪些？

## 4.1 加法和减法

没有看错，指针支持加法和减法，因为指针指向是一块地址，那么如果加一，它指向哪里呢？

![[Pasted image 20251003092307.png\|800]]

指针的加法和加法每次的单位是==**所指向数据类的大小**==

```c
int a = 10;
int *ptr = &a;
printf("原来ptr: %p, 值: %d\n", ptr, *ptr);  
ptr++;
printf("最新的ptr: %p, 值: %d\n", ptr, *ptr);
```

output:
```
原来ptr: 0x16f4c2268, 值: 10
最新的ptr: 0x16f4c226c, 值: 0
```
会发现地址加上了4，代表4个字节，因为int占用4个字节。 如果加上10的话，就代表移动 `10 * 4 = 40`个字节

```
目标地址 = ptr + N * sizeof(int)
```

**在实际开发中，用于数组中的指针移动。**

## 4.2 两个指针相减

前提条件必须是两个相同类型的指针才可以。 其实也就是两个指针相差多少个元素。
使用非常少，仅作了解。   两个指针相加没有任何意义。

```c
#include <stdio.h>

int main()
{
    int arr[10] = {0};
    printf("%ld\n", &arr[9] - &arr[0]); // 9  
    printf("%ld\n", &arr[0] - &arr[9]); // -9 
    return 0;
}
```

## 4.3  两个指针比较

```c
#include <stdio.h>

int main(){
    // declaring array
    int arr[5];

    // declaring pointer to array name
    int* ptr1 = arr;
    // declaring pointer to first element
    int* ptr2 = &arr[0];

    if (ptr1 == ptr2) {
        printf("Pointer to Array Name and First Element "
               "are Equal.");
    }
    else {
        printf("Pointer to Array Name and First Element "
               "are not Equal.");
    }

    return 0;
}
```

## 4.4  ‼️ 一个很重要的东西(跟数组有关)‼️

我们看代码有时候会看到这样的代码

```c
int arr[] = {2,3,4,5,6};

int *ptr = arr;

int *ptr = &arr;  
```

那么`int *ptr = arr;` 和`int *ptr = &arr;` 有啥区别？

- `int *ptr = arr;` 
	- 整个是正确的表达指向数组的方式
	- 在C语言中，除了少数表达式<span class='b'>（比如sizeof(arr)或者&arr）</span>， 当arr单独出现的时候，会自动退化成一个指向其第一个元素的指针
	- 所以 `int *ptr = arr;  int *ptr2 = &arr[0]`  会发现 `ptr == ptr2`
	- `ptr[2]` 其实就相当于 `*(ptr + 3) =  * (ptr + 3 * size(int))`  
- `int *ptr = &arr;`
	- 如果这么写，编译器会给出警告，不会Error。
	- 它代表的含义是：ptr指向整个arr这么一大块内存
	- sizeof(ptr) 会发现占用的就是整个arr大小
	- ❗️❗️ 虽然ptr指向整个arr，但是`ptr[4]`依然能够得到正确的arr中的数据， 那是因为编译器会根据`ptr`的类型来执行指针算术。 它发现ptr还是`int*` 所以，依然是`* (ptr + 4)` 因为此时ptr指向一个元素，所以最终能够找到对应的数据。

总之： 用指针指向数组，用`int *ptr = arr;`

## 4.5 二维数组中使用指针

```c
#include <stdio.h>

// Function to traverse 2D array
// using pointers
void traverseArr(int *arr, int N, int M)
{
    int i, j;
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < M; j++)
        {
            printf("%d ", arr[i * M + j]);
        }
        printf("\n");
    }
}

int main()
{
    int N = 3, M = 2;
    // A 2D array
    int arr[][2] = {{1, 2}, {3, 4}, {5, 6}};
    // Function Call
    traverseArr((int *)arr, N, M);
    return 0;
}
```

会发现` traverseArr((int *)arr, N, M)` 为啥传`(int *)arr`，而不是`arr`呢？
在c语言中，arr作为二维数组名出现在表达式中，会退化成**一个指向数组第一行的指针。**
那么arr就代表为`int (*)[2]`  和函数中的参数不匹配，所以不能这么做，当然可以改函数的参数为`int (*arr)[2]`
但是一般正常的做法是将二维数组拍扁，采用上面代码块中`(int *) arr` 。这个就是指向第一个第一行第一列的那个数据

# 5. 函数指针

> <span class="g">所谓函数指针：就是指向函数的指针</span>

## 5.1 声明和定义

```
返回类型 (*指针变量名)(参数类型列表);
```

```c
#include <stdio.h>

int test(int a)
{
    return a + 1;
}

int main(void)
{

    // 两种方式都可以
    int (*p)(int) = &test;
    // 也可以用地址符&，因为函数名就代表了地址
    // int (*p)(int) = test;
    
    printf("%d\n", p(1));
    return 0;
}
```

## 5.2 调用方法

调用函数指针的话，有两种调用方式，是等价的

```c
// 直接通过指针名调用
int result = p(100);

// 显式的解引用调用
int result = (*p)(100);
```

## 5.3 使用场景

函数指针的主要作用就是实现**间接调用**，让代码更加灵活和通用
1. 实现回调函数
	1. 这个是函数指针最常见的用途。它把函数指针传给另外一个函数执行
	2. 场景： `qsort()`排序函数，可以传`compare`函数，指定是否是倒序

## 5.4 ⚠️ 看两个小代吗 ⚠️

```c
(*(void (*)())0)();
```

以上的代码是啥意思？
首先，从内到外进行拆分：
1. `void (*)()`  这个是函数指针类型， 它是一种类型，跟int char都是一种东西
2. `(void (*) ())0`  这个是强制类型转换，就跟(int)3.4   这种强制类型一样，将常量0强制转为函数指针类型，其值就是内存地址`0x0`
3. `*(...)`  这个就是解引用， 对函数指针进行解引用，最终就是指向函数字体
4. `(....)()`  函数调用，  调用通过解构得到的函数实体

```c
void (*signal(int, void(*)(int)))(int);
```

- 首先，我们要明确，signal是一个函数名，它的参数是int和一个函数指针
- 同时signal函数返回的也是一个函数指针 `void(*)(int)`
上面的代码看起来就很让人抓狂，所以我们可以借助`typedef`来进行重命名

```c
typedef void(*pf_t)(int); // 把void(*)(int)函数指针类型重命名为pf_t

pf_t signal(int, pf_t);  // 这样看起来就简单无比
```

# 6. 函数指针数组

> <span class="g">存放函数指针的数组，就是函数指针数组</span>

> [!note]
> C语言中，实现**策略模式、状态机、或者命令分发**等高级架构设计的基础就是用到了函数指针数组

## 6.1 声明和定义

```c
返回类型 (*数组名[大小])(参数类型列表)

int (*arr[5])(int) = {test};
```

```c
#include <stdio.h>

// 1. 定义函数
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }

// 2. 声明和初始化函数指针数组
// 这个数组存储了三个函数（add, sub, mul）的地址
int (*op_funcs[3])(int, int) = {add, sub, mul};

int main() {
    int x = 20, y = 5;
    int op_code; // 0: 加, 1: 减, 2: 乘
    int result;

    // --- 场景：根据用户输入动态选择操作 ---

    op_code = 1; // 假设用户输入 '1' (减法)
    
    // 3. 调用：使用索引 [op_code] 获取函数指针，然后调用它
    // op_funcs[1] 得到 sub 函数的地址
    result = op_funcs[op_code](x, y); 
    
    printf("Result (Sub): %d\n", result); // 输出 15

    op_code = 2; // 假设用户输入 '2' (乘法)
    result = op_funcs[op_code](x, y); 
    
    printf("Result (Mul): %d\n", result); // 输出 100
    
    // --- 对比传统 Switch 结构 ---
    /*
    // 如果不用函数指针数组，你需要写：
    switch (op_code) {
        case 0: result = add(x, y); break;
        case 1: result = sub(x, y); break;
        case 2: result = mul(x, y); break;
    }
    // 函数指针数组将这整个 switch 结构简化成一行：
    // result = op_funcs[op_code](x, y);
    */

    return 0;
}
```

## 6.2 指向函数指针的数组的指针

首先它是一个指针，它指向的是函数指针数组

```c
// 先把函数指针数组拿过来
int (*arr[5])(int) = {test};
// 它是一个指针 arr -> *p
int (*(*p)[5])(int) = &arr;
```





