
# 1.  整体概述

关于内存管理的，都是`stdlib.h`这个头文件干的活儿，里面有四大函数
- **malloc()** 函数   ：memory allocate   <span class="b">用于内存分配 </span>，在堆上分配指定字节数的连续内存块，但不能进行初始化
- **calloc** 函数 ： contiguous allocate    <span class="b">分配并清零</span>，在堆上分配指定数量和大小的连续内存，并将其所有位初始化为0
- **realloc** 函数： re-allocate    <span class="b">重新调整大小</span>，更改先前分配的内存块大小。如果新尺寸更大，可能原地拓宽，也可能移动到新的更大的内存块
- **free** 函数： <span class="b">释放内存</span>，将先前分配的内存归还给堆，防止内存泄露


# 2. malloc和free


```c
void* malloc(size_t size);
```

这个函数向内存申请一块**连续可用**的内存空间，并返回指向这块空间的开始的指针
- 如果成功，返回一个指向开辟好空间的开始的指针
- 如果失败，返回一个NULL指针，因此malloc的返回值一定要做NULL检查
- 返回值是void* 是一个通用指针，具体使用的时候，需要进行类型强转
- 如果size为0，malloc的行为在标准中没有定义，取决于编译器

free函数，只能释放`malloc()`  `realloc()` `calloc()`  上面三个函数分配的内存空间，其他的内存空间不能用`free`释放。

# 3. calloc

```c
void* calloc( size_t num, size_t size );
```

- num   就是元素个数
- size   每个元素的大小
- 此函数最终会进行初始化成为0

> [!danger]
> `calloc`和`malloc`的区别？
> 它们之间最大的区别就是calloc会进行初始化，malloc没有初始化，只是开辟好空间即可
> 如何选择？
> 如果是需要初始化的用`calloc()`，其余一律用`malloc()`

# 4. realloc

这个才是所谓动态内存管理的核心
`realloc()`函数的出现让动态内存管理更加灵活，可以调整内存的大小

```c
void *realloc( void *ptr, size_t new_size )
```

- `ptr` 需要重新分配内存的指针地址
- `new_size` 重新的内存大小，按照字节来算
- 返回值是调整后的内存起始指针
- `realloc()`函数调整原内存空间大小的基础上，会将原来的数据移动到新的空间，
- `realloc()`函数调整内存的大小有两种情况
	- 情况一： 原有空间后有足够的内存，那么直接在此空间后扩大
	- 情况二： 原有空间不够，需要重新找一块区域，将老的数据迁移过来，并将老的空间内存释放掉

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

int main(void)
{

    int *p = (int *)malloc(sizeof(int) * 5);

    if (p == NULL)
    {
        printf("内存申请失败: %s\n", strerror(errno));
        return 1;
    }
    printf("内存申请成功, p指向的地址为%p\n", p);

    int *np = (int *)realloc(p, sizeof(int) * 20);

    if (np == NULL)
    {
        printf("重新分配内存失败: %s\n", strerror(errno));
    }

    // 一般会将np赋值给原有的p
    p = np;

    printf("新内存申请成功，p指向的地址为%p\n", p);

    return 0;
}

```

> [!danger]
> 如果`realloc(NULL, 40)` 这个就和`malloc(40)` 是一样的。
> ‼️‼️‼️‼️
> 上面的代码为啥不能`int *p = realloc(p, 40)`？ 就是用原有p来接收realloc新的返回值？
> <span class="r">答案是不行的，因为realloc()可能失败，失败的话就会返回NULL，会将原有的p最后变成NULL，导致p丢失了原有的地址，那么原有的内存空间就发生了内存泄露</span>

# 3. 底层原理

`malloc()`和`free()` 这些都不是直接和操作系统打交道，而是通过C语言运行时库（比如glibc，musl）内部的**内存分配器**来实现的

## 3.1 内存分配器（Memory Allocator）

内存分配器是一个比较复杂的东西，它负责管理堆区
1. **管理元数据**   分配器会在每一个已经分配的内存块前存储一小段元数据（块的大小、状态等）。当调用`free(ptr)`时，分配器会查看`ptr`之前的元数据来确定要释放的大小究竟有多大
2. **维护空闲列表**   所有被`free`的内存块会被内存分配器添加到一个空闲列表中，当程序再次请求内存时，优先从这个列表中寻找内存来开辟
3. **合并碎片**  当相邻的两个内存块被释放时，分配器会尝试将它们合并成一个更大的空间快，以此来减少内存碎片。

## 3.2 与操作系统交互

当分配器的空闲列表没有足够大的内存块时，才会向操作系统请求更大的内存。由操作系统层面进行完成。

# 4. 动态内存管理的注意事项

## 4.1  内存泄露

必须遵循**谁分配，谁释放**的原则，低于任何`malloc()`调用，要确保代码路径上有对应的`free()`调用

## 4.2 NULL指针检查

任何调用的`malloc()`这些分配内存的返回值，一定要做NULL指针检查。

## 4.3 野指针和重新释放

- 释放后调用：在`free`后ptr就变成了野指针，如果访问内存数据的话，会出错
- 重复释放： 对一个内存地址调用多次`free` 会破坏分配器内部的空闲列表的元数据，会导致不可预知的错误

为了防止野指针，在释放完之后，需要立即将指针设置为『NULL』

## 4.4 越界访问

不赘述了

## 4.5 性能和线程安全

- **并发问题**  在高并发多线程的情况下，标准的malloc和free通常会使用全局锁在保护堆。会导致严重的锁竞争，降低性能
- **优化**  在高性能的应用中，考虑使用专门为并发设计的高级分配器，比如jemalloc或者tcmalloc。他们通过线程本地存储机制来减少锁竞争。

> [!note]
> 如何使用jemalloc呢？
> jemalloc是facebook开源的一款高细嫩通用内存分配器，能够在多线程的环境下具有卓越的低锁竞争。
> 1. 系统先安装jemalloc的库
> 2. 编译和链接写的C程序
> 3. 最终运行时是用的jemalloc的实现就行了。











