
# 1. 定义数组

```c
//Partial Initialisation
int arr[5] = {2, 4, 8};

//Skiping the size of the array.
int arr[] = {2, 4, 8, 12, 16};  

//initialize an array with all elements set to 0.
int arr[5] = {0};

// 同样可以先声明，后进行赋值
int arr[4];
arr[0] = 1;
arr[1] = 5;

// 需要注意的是
int size = 20;
int arr[size] = {0};  // ❗️❗️❗️ 这个是错误的，必须要把size设置为常量才可以
```

> [!danger]
> 需要注意的是，在声明数组后，不能直接进行赋值，比如
> `int arr[1];   arr = {10};`  这个是错误的，一定要注意！！！！！❗️❗️❗️❗️❗️
> 可以通过数组的copy来实现


# 2. 数组的大小
其他的使用和Java中一样， 唯一需要注意的就是数组的大小

```c
int arr[] = {1, 4, 6, 7};
int size = sizeof(arr) / sizeof(arr[0]);
```

# 3. 函数中如何返回数组

在C语言中一个函数返回数组是比较困难的，它不像Java那样方便，因为C语言函数的返回值不能是数组，这个稍微有点难度

### 3.1 返回指向数组第一个元素的指针（最常用）

```c
#include <stdio.h>
#include <stdlib.h>

int *get_arr(int size)
{
    int *arr = (int *)malloc(size * sizeof(int));
    if (arr == NULL)
    {
        printf("分配内存失败\n");
        return NULL;
    }

    for (int i = 0; i < size; i++)
    {
        arr[i] = i + 1;
    }

    return arr;
}

int main()
{
	// 获取数组
    int *arr = get_arr(5);

    if (arr == NULL)
    {
        return -1;
    }

    for (int i = 0; i < 5; i++)
    {
        printf("%d\t", arr[i]);
    }
	// 最后一定要释放内存
	free(arr);

    return 0;
}

```

### 3.2 采用静态数组的方式

```c
#include <stdio.h>

int *get_arr_static()
{
    static int arr[5] = {1, 3, 5, 7, 9};
    return arr;
}

int main()
{
    int *arr = get_arr_static();
    for (int i = 0; i < 5; i++)
    {
        printf("%d\t", arr[i]);
    }
    return 0;
}
```

### 3.3 将数组作为参数传给函数，函数内进行填充数据

```c
// 函数现在接受一个指针（即要填充的数组）和一个大小
void fill_array(int* output_array, int size) {
    for (int i = 0; i < size; i++) {
        output_array[i] = (i + 1) * 2;
    }
}

int main() {
    int arr[5]; // 调用者在栈上创建数组
    
    // 将数组的地址（&arr[0] 或 arr）和大小传给函数
    fill_array(arr, 5); 
    
    printf("填充后的数组内容: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]); // 2 4 6 8 10
    }
    return 0;
}
```

### 3.4 将数组封装到一个结构体内

```c
#define FIXED_SIZE 4

// 1. 定义一个包含数组的结构体
typedef struct {
    int data[FIXED_SIZE];
} ArrayWrapper;

// 2. 函数返回这个结构体
ArrayWrapper create_struct_array(int base) {
    ArrayWrapper result;
    
    for (int i = 0; i < FIXED_SIZE; i++) {
        result.data[i] = base + i;
    }
    
    // 3. 返回结构体 (整个结构体内容被复制到调用者处)
    return result; 
}

int main() {
    // 接收返回的结构体
    ArrayWrapper myWrapper = create_struct_array(50);
    
    printf("返回的结构体数组内容: ");
    for (int i = 0; i < FIXED_SIZE; i++) {
        printf("%d ", myWrapper.data[i]); // 50 51 52 53
    }
    return 0;
}
```

# 4. 排序

采用内置的快速排序

```c
#include <stdlib.h>
#include <stdio.h>

// void *a  这个在C语言中代表通用的指针
int compare(const void *a, const void *b)
{
    // (int *)a 这一步是强制转换a指针指向一个整型的数据
    // *(int *)a   这一步是进行解构 ，获得指针指向的值
    return (*(int *)a) - (*(int *)b);
}

int main()
{
    int arr[] = {6, 4, 7, 9, 2, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);

    qsort(arr, size, sizeof(int), compare);

    for (int i = 0; i < size; i++)
    {
        printf("%d\t", arr[i]);
    }
    return 0;
}
```

# 5. 数组和指针

```c
int arr[5] = {1,3,4,6,7};

int *ptr = arr;// 相关的解释，请看指针那一块
int (*p)[5] = &arr;  // 这个p指针指向整个int arr[5]数组
int *p[10] = {&a};   // 这个代表是一个数组，里面存放的int*指针
```

```c
char *arr[5] = {2}; // ❌ ❌ ❌ 这个是错误的

char *arr[5] = {0};  // ✅ ✅ ✅
```

为啥一个数组的元素是`char*`指针类型，但是上面的{0}是正确的呢？
` = {0} ` 在C语言中是一种标准的、简化的初始化多元素数组或者结构体的方法。
在此处，代表所有的元素都是指向NULL

# 6. 数组指针的作用

`int (*p)[5] = &arr; `  这个就是数组指针，它是一个指向整个数组的指针。那么它有什么用呢？
主要用在处理二维数组上，当有一个二维数组`int matrix[R][C]` 数组名 `matrix`本身退化成**一个指向第一行数组**的指针。因此，你需要一个数组指针来正确指向它。

```c
void print_matrix(int (*p)[5], int rows) {
    // p 的类型是 "指向包含 5 个 int 的数组的指针"
    for (int i = 0; i < rows; i++) {
        // p + i 移动 i 行（每行 5 个 int）
        // *(p + i) 解引用得到第 i 行的数组
        for (int j = 0; j < 5; j++) {
            // (*(p + i))[j] 正确访问第 i 行第 j 列的元素
            printf("%d ", (*(p + i))[j]);
        }
        printf("\n");
    }
}

int main() {
    int data[3][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};
    
    // 传入的 data 自动退化为 int (*)[5] 类型
    print_matrix(data, 3); 
    
    return 0;
}
```

# 7. 二维数组

C语言中的二维数组，可以用扁平化来初始化

```c
int data[3][5] = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15}};
// 这种就是扁平化，在C语言中是合法的
int data[3][5] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
```

# 8. 数组作为函数参数

在C语言中，当你将一个数组名传递给函数的时候，C语言有一个核心规则叫做：**数组退化**
> <span class="b">数组名作为函数的参数传递时，它会退化成一个指向其首元素的指针</span>

所以：以下三种方式都是一样的

```c
void func_A(int a[]); 
// 编译器视为：void func_A(int *a);

void func_B(int *a);
// 编译器视为：void func_B(int *a);

void func_C(int a[100]); 
// 编译器忽略 [100]，仍然视为：void func_C(int *a);
```

所以，我们传递数组的时候，一定要把数组的长度给传过去，因为只有指针，函数不一定知道数组的大小

```c
#include <stdio.h>

// 总是同时传递数组的首地址和大小
void print_array(int arr[], size_t size) {
    // 这里的 sizeof(arr) 只是指针大小，不可用
    printf("函数内元素个数: %zu\n", size); 
    for (size_t i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int data[] = {10, 20, 30, 40, 50};
    // 在 main 函数内可以计算出大小
    size_t len = sizeof(data) / sizeof(data[0]); 

    // 传递地址（退化后的指针）和大小
    print_array(data, len); 
    
    return 0;
}
```

# 9.  一个经典的面试题

```c
int main(int argc, char *argv[])
{
    long i;
    long a[16];
    for (i = 0; i <= 17; i++)
    {
        a[i] = 0;
        printf("%ld\n", i);
    }
    return 0;
}
```

以上代码有哪些问题？请问为啥？
- 首先我们看到肯定是数组越界了，`a[16]` 和`a[17]` 会导致数组内存区域外的数据被修改了
- 在局部变量中，`i`可能和`a`数组是仅仅挨着的，那么`a[16]` 修改的那块内存区域就是变量i的值，最终导致i又变成0了，然后由开始循环了，最终导致死循环
- 同时`a[17]`对应的内存区域可能是main函数的返回地址或者argc的值，又破坏了关键的栈数据

# 10. 另外一道经典的题

```c
int main(void)
{
    char *str = malloc(100);
    strcpy(str, "hello");
    free(str);

    if (str != NULL)
    {
        strcpy(str, "zmg");
        printf("%s\n", str);
    }
    return 0;
}
```

首先这个不是标准的代码，会有问题，就是free后，继续放了被释放的内存中间。
但是在mac上运行的时候，发现并没有出现问题，那是因为我幸运，为啥呢？
现代操作细绒和高性能内存分配器（比如mac默认的moalloc()实现），**内存释放是惰性的**
在free后，不代表立马就被回收被别人占用了，只是会被内存分配器标记为空闲，不会立即将内存映射去掉，所以我们再去使用的时候，发现依然可以使用，所以只是运气好，实际开发中不能这么用。