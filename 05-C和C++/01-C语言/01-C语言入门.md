
# 1. 一个暴论

学好C语言，基本上任何语言都不在话下，因为，C语言是现代语言之母。

> [!tips]
>  C11、C17、C23的区别？？？？
>  
>  - C11 是2011年发布的标准，是C语言一个重大更新，核心特性有：线程、泛型、以及更加现代化的一些优化
>  - C17 是2017年发布的标准，主要是修复C11的bug，没有新增特性
>  - C23 是2023年发布的标准，一次重大的更新，提升语言的安全性和可用性，简化部分语法、引入新的关键字等
>
>- 🈯️ 🈯️用vscode开发，安装插件`C/C++ Extension Pack`，里面包含好几个插件，是开发主要的帮手

# 2. 一个最简单的C代码

```c
# include<stdio.h>

int main()
{
	// this is a first c program
	printf("Hello World");
	return 0;
}
```

# 3. C语言的编译过程

```shell
gcc -Wall -save-temps filename.c –o filename
```

以上命令会生成几个文件 （以`hello.c`为例）
- hello
- hello.i
- hello.o
- hello.s

1. **Pre-processing  预处理**， 用预处理器进行处理
	1. 此阶段，移除注释
	2. Expansion (展开/膨胀) 宏      (这些都是进行文本替换)
	3. expansion  of the included files  （同样也是文本替换）
	4. Conditional Compilation   条件编译  <span class='r'>根据宏或者编译环境，动态选择性地包含或者排除代码片段</span>
		1. 跨平台兼容性适配
		2. 功能模块的开关空值
		3. Debug的隔离等
	5. 最终会生成`hello.i`文件，里面会有很多自动生成的代码，我们自己的代码通常在最后
2. **Compiling 编译**  使用编译器进行处理
	1. 编译是根据上一步生成的`.i`文件来进行编译的
	2. 最终生成一个汇编级别(Assembly-level)的指令文件`hello.s`文件
3. **Assembling 汇编**
	1. 将编译生成的`.s`文件通过汇编器转为`.o`文件，这是一个二进制文件，打开看就没有意义了
4. **Linking   链接阶段，转为可执行文件**
	1. 将`.o`汇编文件，转为最终可执行的`hello`文件
	2. 一个合法的可执行程序必须有一个入口点==，也就是说必须有main函数，要不然最后无法进行链接，会报错==
	3. linking有两个类型
		1. 静态linking  ： 所有的代码都会copy到一个文件中，然后去执行这个文件  `gcc -static hello.c -o hello` 这个就是静态linking
		2. 动态linking  ： 仅将库的引用嵌入可执行文件，运行时动态加载共享库(如`.so`文件)
	4. gcc默认是编译为**动态linking**

> [!danger]
> 1. 在上面编译的时候，在pre-processing 和 compiling 之间还会生成一个`.bc`文件，这个文件是现代编译器优化的一个过程。
> 2. 如何查看这执行文件是否是动态类型
> 	1. `ldd hello`  这个命令是linux特有
> 	2. `otool -L hello`  这个是mac上的命令，会列出依赖的库，如果有依赖的库，那么就是动态linking

# 4. 根据头文件中声明，如何找到函数的实现？

1. 在编译阶段，只需要头文件即可，不需要对应的实现。只需要告诉编译器当前的函数长什么样即可。
2. 在链接阶段，就需要去查找函数的定义了
	1. 它发生在所有源文件都已经被编译成独立的目标文件之后
	2. 你需要告诉编译器包含的所有文件 `gcc main.c my_func.c -o program` ， 这样链接器会拿到所有的`.o`文件
	3. 链接器会查找符号定义
		1. 比如：链接器在`main.o`中发现了对`my_function`的外部引用（会有占位符提示）
		2. 它会遍历检查所以的其他目标文件寻找函数的实现，最终比如在`my_func.o`中找到了`my_function`的实际定义
		3. 解析地址： 链接器将`my_func.o`中的`my_function`的实际内存地址替换掉`main.o`中留下的『占位符』
3. 至此，链接器将所有的目标文件以及必要的库文件都合并到一起了，生成了一个完整的可执行文件

> [!note]
> 可以单独对某个源文件进行编译
> `gcc -c my_func.c -o my_func.o`   最终生成一个汇编库文件
> 实际开发，我们不会一个个linking，而是通过makefile 文件交给make来构建

# 5. C语言的静态库和动态库有啥区别？ 如何编译生成？

## 5.1 静态库和动态库的区别

和Java一样，为啥需要打成一个库呢？肯定是为了方便复用，这个是毋庸置疑的。
在C语言中，库主要分成**静态库**和**动态库**，它们最大的区别在于<span class="b">代码嵌入和链接发生的事件</span>

| 特性          | 静态库                                                      | 动态库                                                                                          |
| ----------- | -------------------------------------------------------- | -------------------------------------------------------------------------------------------- |
| **文件拓展名**   | Linux/Mac： `.a`  (archive)<br>Windows：  `.lib` (library) | Linux ： `.so` (shared object)<br>Mac:     `dylib` <br>Windows： `.dll` (dynamic Link Library) |
| **链接时间**    | 链接时                                                      | 运行时                                                                                          |
| **可执行文件大小** | 大                                                        | 小                                                                                            |
| **内存占用**    | 链接器将库代码复制到每个可执行文件中，导致文件很大                                | 多个程序可以共享同一个动态库，节省内存                                                                          |
| **更新维护**    | 如果库要更新，所有使用该库的程序都要重新链接/编译                                | 如果库更新，只要更新动态库就行，程序无需重新链接                                                                     |
| **加载速度**    | 启动速度快， 所有文件都在内存中                                         | 启动时需要加载以及链接库，稍微慢点                                                                            |

## 5.2  如何编译静态库和动态库

### 5.2.1 编译静态库

编译静态库分成两步： 生成目标文件和打包

1. 生成目标文件`.o`
	
```shell
# 使用 -c : 只编译，不链接，不用找main函数
gcc -c my_func.c -o my_func.o
```

2. 使用`ar`打包
使用`ar` (archive)工具将所有`.o`文件打包成静态库文件
- `r`：  插入或者替换文件
- `c` ：创建库文件
- `s`： 写入索引（加快链接速度）

```bash
# ar rcs lib<库名>.a <目标文件>....
ar rcs libmyfunc.a my_func.o
```

3. 静态库的使用
在编译你的主程序时，告诉`gcc`库文件的位置和名称
```bash
# 假设主程序是main.c
# -L. ： 链接器在当前目录中查找库文件
# -lmyfunc: 链接libmyfunc.a  (去掉 lib 和 .a)
gcc main.c -L.  -lmyfunc -o my_program
```

### 5.2.2  编译动态库

编译动态库需要使用特定的选项，确保生成的代码是位置无关的。

1. 生成位置无关代码`.o`
`-fPIC`  代表的是生成位置无关的目标文件

```bash
# -fPIC: 必须的选项，确保代码能在内存中被任意加载
gcc -c -fPIC my_func.c -o my_func.o
```

2. 使用`gcc`链接成动态库


```bash
# -shared: 告诉链接器生成共享对象文件  这个是linux系统
gcc -shared -o libmyfunc.so my_func.o

# -dynamiclib: macOS 使用这个选项代替 -shared  这个是Mac系统
gcc -dynamiclib -o libmyfunc.dylib my_func.o
```

3. 动态库的使用
链接方式和静态类似
```bash
# 假设主程序是 main.c
gcc main.c -L. -lmyfunc -o my_program
```

4. 运行时的配置(重要‼️)
在编译成功后，可执行文件还需要在运行时能够找到`libmyfunc.so`或者`libmyfunc.dylib`
- **Linux**： 需要将库文件路径添加到环境变量`LD_LIBRARY_PATH` 或者在`/etc/ld.so.conf`配置中
- **macOS** :   需要将库文件添加到环境变量`DYLD_LIBRARY_PATH`中
- 最简单的方式是：将动态库文件复制到系统标准库下`/usr/local/lib` 

### 5.2.3 关于静态库编译的补充

使用静态库时，链接的顺序非常重要。通常的规则是
**谁调用谁，谁在前**
如果你的`main.c`调用了`libA`中的函数，而`libA`又调用了`libB`中的函数，那么正确的顺序是

```bash
gcc main.c -lA -lB -o program # 错误 ❌ ❌
gcc main.c -lB -lA -o program # 错误 ❌ ❌

# 正确顺序：调用者在前，被调用者在后
gcc main.c libA.a libB.a -o program  # 推荐使用完整文件名或精确控制 L/l 顺序 ✅
```

### 5.2.4 windows下静态库的使用

一般我们会在windows下的c文件项目中看到`#pragma comment(lib,"xx.lib")`这种方式集成静态库，这个是windows下特有的处理指令，因为windows的编译器MSVC它能够识别并处理， 所以在linux或者mac下不能这么做。

### 5.2.5 mac开发的C项目，能够编译成lib或者linux下的a或者so吗

macOS默认的编译工具链是不能直接生成windows下可用的`.lib`静态库文件的， 主要格式不一样，缺少相关的格式配置。

解决方案： 
1. 使用`MinGW`或者`Clang/LLVM`这样的交叉工具链，这个就是交叉编译。
	1. 安装工具链  `x86_64-w64-mingw32-gcc`和链接器
2. 使用windows虚拟机

### 5.2.6 mac下能否开发windows的c项目

是可以的，但是编译的时候要用交叉编译，同时运行测试的时候，需要用windows进行测试。
因此，本身代码是可以在mac上编写的，但是最终的编译需要进行交叉编译，最终编译的程序才能在windows下运行。

# 6. 标识符和变量

此处不用多做赘述，因为这个跟Java一样，就不用纠结了，只是有一个问题，就是开发规范，到底使用下划线风格还是小驼峰风格？
我的建议是，跟Java保持一致，直接使用小驼峰风格就行，但是同一份代码中别有不同的风格

# 7. 数据类型

基础类型只有
1. int
2. long
3. short
4. float
5. double
6. char
7. bool  <span class='r'>只有在c23是标准的关键字，在c17中使用的话，需要头文件</span>`<stdbool.h>`
8. void

> [!danger]
> 这个非常重要，这个也是C/C++不安全的地方
> 1. int所占的字节是多少？  
> 	1. 这个取决于环境，如果是16位系统上可能是2个字节，在64个字节中可能是4个或者8个字节。<span class='r'>特别坑爹</span>
> 	2. Java就是不管什么环境，都只是4个字节
> 2. unsigned int  这个是无符号的int，正常应该只能存储>=0的数据， 但是同样也有<span class='r'>坑爹的地方</span>，如果你赋值为负数，就会进行隐式类型转换，会将这个负数转为很大的正整数，主要是最高位会被作为0，这个表示为无符号，所以就是巨大的正整数， 因此使用`unsigned int`的时候一定要注意

在printf输出的时候进行格式化，对照表

| 类型    | 格式化占位符   |     | 类型           | 格式化占位符 |     | 类型     | 格式化占位符 |
| ----- | -------- | --- | ------------ | ------ | --- | ------ | ------ |
| int   | %d 或者 %i |     | unsigned int | %u     |     | char   | %c     |
| char* | %s       |     | float        | %f     |     | double | %lf    |
| long  | %ld      |     | short        | %hd    |     | 指针     | %p     |
```c
#include <stdio.h>
int main(){
    // Use sizeof() to know size
    // the data types
    printf("The size of int: %d\n",
        sizeof(int));
    printf("The size of char: %d\n",
        sizeof(char));
    printf("The size of float: %d\n",
        sizeof(float));
    printf("The size of double: %d",
        sizeof(double));

    return 0;
}
```

> [!tips]
> C语言中，声明的变量的默认值是啥？
> 在C语言中，静态存储期的变量，默认值为零
> - 全局变量   以及静态变量，默认值为零值，比如int就是0，double就是0.0，指针类型就是NULL
>
> 自动存储期变量： 没有默认值(垃圾值)   就是函数内使用的变量， 默认值可能是一个随机数据
>主要是为了追求极致的性能，不会浪费事件去清理或者初始化这块内存。


```c
  signed s;
  unsigned u;
  long l;
  long long ll;
```

以上声明正确吗？  答案是正确的。因为C语言中可以隐式int， signed s 就相当于  signed int s  是对的

# 8. 常量和枚举

1. 使用`const`修饰的常变量，❗️❗️ 这个const修饰的依然是一个变量，只是它有了常量的属性，不能修改
2. 使用#define 来定义一个常量，这个是真正的常量  `#define SIZE 9`
3. 枚举常量

```c
const int n = 9;
int arr[n] = {1, 3};
// ❌ ❌ ❌ warning: variable length array folded to constant array as an extension 
// 定义数组的时候数组的大小一定要是常量，const int是一个常变量，本质上还是一个变量
```

```c
// 定义枚举
enum Color
{
    BLUE,
    GREEN,
    RED
};

enum Color c = RED;

```

在枚举中给每个枚举key赋值。

```c
#include <stdio.h>

// Defining enum
enum enm {
    a = 3, b = 2, c
};

int main() {

    // Creating enum variable
    enum enm v1 = a;
    enum enm v2 = b;
    enum enm v3 = c;
    printf("%d %d %d", v1, v2, v3);
    return 0;
}
```
# 9. input和output

## 9.1 output

- printf() 函数
- fputs("your text", stdout)

> [!info] 
> printf()函数是有返回值的，它的返回值就是最终成功输出的字符数量

## 9.2 input

- scanf("formatted_string", address_of_variables/values);  函数

```c
int main()
{
    int age;
    printf("请输入年龄");
    scanf("%d", &age);
    printf("年龄是: %d", age);
    return 0;
}
```


# 10. 操作符

和Java一样，没有啥特别的， 在C语言中，也是有三元表达式的。

# 11. if -else 和 switch

C语言中，if的条件不一定是boolean值，这个跟Java不一样
- 零值  即为false
- 非零  即为true

同样的，swtich的用法和Java也是一致的

```c
#include <stdio.h>
int main() {
    // variable to be used in switch statement
    int var = 18;
    // declaring switch cases
    switch (var) {
    case 15:
        printf("You are a kid");
        break;
    case 18:
        printf("Eligible for vote");
        break;
    default:
        printf("Default Case is executed");
        break;
    }
    return 0;
}
```

在C语言中，有个`goto`的关键字，是用于在if判断或者循环中，进行跳到指定的地方，其实在实际开发中不要使用

# 12. 循环

和Java是一样的，但是C语言中不提供for-each
表达无限循环

```c
for (;;) {}

while(1) {}
```

# 13. 函数

和Java定义函数是一样的， 通过`<stdarg.h>`头文件中的宏，来实现可变参数

```c
#include <stdio.h>
#include <stdarg.h>

// 第一个参数 count 指定了后面可变参数的数量
// ... 表示接下来的参数数量和类型是可变的
int sum(int count, ...) {
    int total = 0;
    
    // 1. 定义一个 va_list 类型的变量
    va_list args;
    
    // 2. 使用 va_start 初始化 va_list 变量
    //    count 是最后一个固定参数
    va_start(args, count);
    
    // 3. 循环使用 va_arg 获取每个参数
    for (int i = 0; i < count; i++) {
        // 获取一个 int 类型的参数，并加到 total 上
        total += va_arg(args, int);
    }
    
    // 4. 使用 va_end 清理
    va_end(args);
    
    return total;
}

int main() {
    // 调用 sum 函数
    printf("Sum(2, 10, 20) = %d\n", sum(2, 10, 20)); // 2个可变参数
    printf("Sum(4, 5, 10, 15, 20) = %d\n", sum(4, 5, 10, 15, 20)); // 4个可变参数
    printf("Sum(1, 100) = %d\n", sum(1, 100)); // 1个可变参数
    
    return 0;
}
```

C语言中不支持参数的默认值，但是可以通过宏来实现多函数的封装，类似Java中的重载

> [!danger]
> 在现代语言开发中，函数的参数传递都是值传递或者引用副本传递，这个跟Java上理解的是一样，但是C++和php提供了真正意义上的『按引用传递』，让形参成为实参的别名，修改这个形参的数据，会导致实参也会变化

## 13.1 inline function

在C语言中，inline函数是一种建议性优化的关键字，主要是用于向编译器建议将函数的内容直接**嵌入或者展开**到调用它的地方，而不会通过传统方式进行压栈等操作。这个就可以理解为，将inline函数的内容替换到调用的地方而已。

1. 性能优化，消除函数调用的开销
2. 它是一个建议性，最终的决定权在编译器，它可能拒绝内嵌，比如函数体复杂，它就依旧编译成一个普通的函数

```c
#include <stdio.h>

// Inline function in C
inline int foo() {
    return 2;
}

int main() {
    int res;
    // inline function call
    res = foo();
    printf("%d", res);
    return 0;
}
```

以上的代码如何直接运行的话，就会出现一个问题
```
Undefined symbols for architecture arm64:
  "_foo", referenced from:
      _main in str-972876.o
ld: symbol(s) not found for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```

这个是因为编译器不进行内嵌处理，最后找不到方法foo。 要解决这个问题
1. 直接通过命令`gcc hello.c -o hello -O1` 来开启优化，这样编译的就会嵌入进去，最后不报错
2. 在一个源文件中提供外部定义
	1. 先在头文件中进行定义`inline`函数
	2. 在使用的地方进行`extern`外部定义

```c title=头文件header.h
#ifndef HEADER_H
#define HEADER_H

inline int foo()
{
    return 2;
}
#endif

// 或者采用 #pragma once的方式，这样宏也只是被创建一次
#pragma once
inline int foo()
{
    return 2;
}
```

```c title=使用的文件
#include "header.h"

extern inline int foo();

int main()
{
    int res;
    res = foo();
    printf("%d", res);
    return 0;
}
```

3. 最简单的方案就是不用`inline`函数
4. 可以使用`static inline`函数

```c
static inline int foo()
{
    return 3;
}
```

5. 使用预定义  (这个还不如用第三种方式，直接去掉inline)

```c
// 先预定义
int foo();
inline int foo()
{
    return 3;
}
```

inline function 主要用途
1. 函数很小，但是调用的比较频繁，可以通过`inline`函数进行优化
2. 嵌入式中对性能要求比较高的时候
## 13.2 嵌套函数

暂时不用了解，在C标准里面不支持这个嵌套函数，但是在GCC编译器中支持这个增强语法

```c
#include <stdio.h>

void outer_function(int x) {
    int y = 10; // 外部函数的局部变量
    
    // ----------------------------------------------------
    // 嵌套函数定义：只有 outer_function 才能看到它
    int inner_function(int z) {
        // 访问外部函数（outer_function）的局部变量 y
        return x + y + z; 
    }
    // ----------------------------------------------------

    // 在外部函数内部调用嵌套函数
    int result1 = inner_function(5);
    printf("Result 1: %d\n", result1); // 预期: x + y + 5 (假设 x=1)
    
    // GCC 允许你获取嵌套函数的地址
    int (*f_ptr)(int) = inner_function;
    
    // 通过函数指针调用嵌套函数
    int result2 = f_ptr(20);
    printf("Result 2: %d\n", result2); // 预期: x + y + 20 (假设 x=1)
}

int main() {
    outer_function(1);
    
    // 尝试在外部调用嵌套函数会编译错误或链接错误：
    // inner_function(1); // 错误：在 main 作用域中未定义
    
    return 0;
}
```

主要是一个可见性的问题，类似闭包的概念

## 13.3 声明函数

1. 直接在c文件里面声明函数
	1. 不需要给出函数体

```c
// 不用给出函数体
int add(int x, int y);
// 可以简写，只要给出参数类型和个数就行
int add(int, int);
```

## 13.4 void函数参数

其实C语言中的main函数的标准写法是

```c
int main(void)
{
	return 0;
}
```

为啥用`void`呢？ 这个是告诉别人此函数不接受任何参数，如果直接`int main()` 别人依然可能会传值，编译器不会报错，只是在运行时会报错

2. 一般写在头文件中进行函数声明





# 20. mac上如何安装gdb或者使用lldb

有时候运行程序直接崩溃了，导致没有日志输出，我们并不知道如何排查问题

可以安装gdb然后用gdb进行debug

💀💀 可是我在本地mac上已经安装了gdb，但是最终执行的时候，发现还是不行，不清楚是啥问题，应该是兼容性的问题

1. `brew install gdb` 安装gdb
2. 打开『钥匙串』创建一个证书
	1. 证书类型『代码签名』
	2. 勾选『覆盖默认值』
	3. 其他的都是默认的就行
	4. 确保在创建证书时选择 系统 钥匙串，不是登录钥匙串
3. 然后在`/opt/homebrew/Cellar/gdb/16.3/share/gdb` 下创建`gdb-entitlement.xml`文件
4. 最后执行命令 `codesign -f --entitlements gdb-entitlement.xml -s gdb-cert $(which gdb)`

按照以上的逻辑应该已经安装好了，但就是执行c可执行文件的时候没有效果

所以在mac下用自带的`lldb`进行替换

```shell
# 1. 编译
gcc -g hello.c -o hello

# 2. 用lldb执行
lldb ./hello
```

在程序崩溃后，输入`bt`命令，就看出出错的代码行在哪儿了。
![[Pasted image 20251003171636.png]]
# 21. C标准库的API文档

目前最全和最权威的API文档地址 ：[https://cppreference.com/index.html](https://cppreference.com/index.html)

