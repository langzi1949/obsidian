
# 1. 整体的流程

1. **打开文件**： 使用`fopen()`函数获取文件指针 （`FILE*`）
2. **读写文件**：使用相关API进行调用操作
3. **关闭文件**： 使用`fclose()`函数来释放资源

# 2. 文件打开

```c
FILE *fopen(const char *filename, const char *mode);
```
- `filename`  要打开的文件名（可以是相对路径或者是绝对路径）
- `mode`   打开方式， 常见如下格式

| 模式 <img  style="width:100px"></img> | 说明                          | 如果指定文件不存在 |
| ----------------------------------- | --------------------------- | --------- |
| r                                   | 只读，文本模式，文件必须存在              | error     |
| w                                   | 只写，文本模式，若文件存在则清空原有数据；不存在则创建 | 新建        |
| a                                   | 追加，文本模式，在文件末尾写入；文件不存在则创建    | 新建        |
| rb                                  | 只读，二进制模式                    | error     |
| wb                                  | 只写，二进制模式，清空 or 创建           | 新建        |
| ab                                  | 追加，二进制模式                    | error     |
| r+                                  | 读写，文本模式，文件必须要存在             | error     |
| w+                                  | 读写，文本模式，清空 or 创建            | 新建        |
| a+                                  | 读写（追加模式） 文本模式               | 新建        |
| rb+  or  wb+  or  ab+               | 对应的二进制读写模式                  | 跟上面逻辑一致   |

# 3. 常用的读写函数

## 3.1 fgetc() 和fputc()

> 字符输入/输出函数

```c
int c;
while ((c = fgetc(fp)) != EOF)
{
	printf("%c\n", c);
}
```

## 3.2 fgets()和fputs()

> 字符串输入/输出函数

```c
char arr[200];
char *str = fgets(arr, 10, fp);

printf("读取的数据%s\n%s\n", arr, str);

int a = fputs("\n上海", fp);
printf("写入的数据的字节数: %d\n", a);
```

## 3.3 fscanf()和fprintf()

> 格式化字符串的输入/输出函数

```c
struct Stu stu = {"zmg", 19, 99.3f};
fprintf(fp, "%s %d %f", stu.name, stu.age, stu.score);
```

```c
struct Stu stu = {0};
scanf(fp, "%s %d %f", stu.name, &(stu.age), &(stu.score));
```

需要注意的是，结构体要声明成如下的方式才可以
```c
struct Stu
{
    char name[20];
    int age;
    float score;
};
```

name必须是字符数组表示的字符串才行，如果是指针`char *name`，以上的代码需要调整一下，在赋值的时候，`stu = {0}`的时候，`*name`指向的是NULL，并没有分配内存中间，导致最终的赋值的时候会报错，所以必须要进行内存分配才行
```c
// 如果struct中用指针表示字符串的话，必须进行分配内存，才可以
stu.name = malloc(sizeof(char) * 20);
```

## 3.4 fread()和fwrite()

> 二进制读写操作

```c
// b代表是按照二进制
FILE *fp = fopen("/Users/chenzehao/cppWorkspace/hello-c/in/hello02.txt", "wb");
if (fp == NULL)
{
	return 1;
}

struct Stu stu = {"zmg", 28, 97.0f};

// 写一个struct的信息
fwrite(&stu, sizeof(struct Stu), 1, fp);

fclose(fp);
fp = NULL;
return 0;
```

```c
FILE *fp = fopen("/Users/chenzehao/cppWorkspace/hello-c/in/hello02.txt", "rb");
if (fp == NULL)
{
	return 1;
}

struct Stu stu = {0};

fread(&stu, sizeof(struct Stu), 1, fp);
printf("%s %d %f\n", stu.name, stu.age, stu.score);
fclose(fp);
fp = NULL;
return 0;
```

# 4. 文件关闭

```c
fclose(fp);
// 最好再将fp指向NULL
fp = NULL;
```


# 5. 其他的函数

## 5.1 sscanf()和sprintf()

这个主要是进行格式化数据，最后输出一个字符串，反之，亦是。

```c
int sscanf( const char *restrict buffer, const char *restrict format, ... );


int sprintf( char* restrict buffer, const char* restrict format, ... );
```

- **sscanf()**
	- 从字符串`buffer`中按照`format`的格式解析数据，最终存储到后续参数列表中
	- 使用场景：
		- 解析结构化的字符串（日志；配置；时间字符串等）

```c
char str[] = "2024-10-17 15:30";
int year, month, day, hour, min;
sscanf(str, "%d-%d-%d %d:%d", &year, &month, &day, &hour, &min);
// 解析后：year=2024, month=10, day=17, hour=15, min=30
```

- **sprintf()**
	- 将格式化的数据写到字符串`buffer`中
	- 使用场景
		- 拼接字符串或者生成结构化的字符串
		- 将数值转为字符串等
	- 注意事项
		- <span class='r'>确保buffer有足够的空间，避免缓冲区溢出，可以使用更加安全的 snprinf  可以指定最大写入长度</span>

```c
char buf[50];
int id = 100;
char name[] = "Alice";
sprintf(buf, "User{id=%d, name='%s'}", id, name);
// buf 内容："User{id=100, name='Alice'}"
```

## 5.2 feof()

用于检查文件是否到达末尾

```c
int feof( FILE *stream );
```

判断文件流`stream`的当前位置是否已经到达文件末尾（0：未到； 非0：已到末尾）

```c
FILE *fp = fopen("file.txt", "r");
int ch;
while ((ch = fgetc(fp)) != EOF) {  // 读取字符直到EOF
    putchar(ch);
}
if (feof(fp)) {  // 确认是因文件结束导致的EOF
    printf("\n文件读取完毕\n");
}
fclose(fp);
```

## 5.3 ferror()

```c
int ferror(FILE *stream);
```

判断文件流`stream`上是否发生过错误（0： 没有错误； 非0： 有错误）
使用场景：
- 读取/写入文件失败后，区分是『文件结束』还是『操作错误』（比如：权限不够、磁盘满等）
- 一般需要配合`feof()`排查文件操作异常的原因

```c
FILE *fp = fopen("file.txt", "r");
char buf[100];
if (fgets(buf, 100, fp) == NULL) {
    if (feof(fp)) {
        printf("已到文件末尾\n");
    } else if (ferror(fp)) {
        perror("读取错误");  // 输出具体错误信息
    }
}
fclose(fp);
```

## 5.4 rewind()

```c
void rewind( FILE *stream );
```

将文件流`stream`的当前位置重置到文件的开头，同时清除文件的错误标志。 这个函数等价于
`fseek(stream, 0, SEEK_SET)`

使用场景
- 需要重新读取文件内容时

```c
FILE *fp = fopen("data.txt", "r");
// 第一次读取
char first_line[100];
fgets(first_line, 100, fp);

rewind(fp);  // 回到文件开头
// 第二次读取（从头开始）
char buf[100];
while (fgets(buf, 100, fp)) {
    // 处理每一行
}
fclose(fp);
```

## 5.5 fseek()

```c
int fseek( FILE* stream, long offset, int origin );
```

将文件流`stream`的当前位置移动到以`origin`为基准，偏移`offset`字节的位置   （0： 成功； 非0： 失败）
- `offset`  偏移量  正数为先后移动，负数表示先前移动
- `origin`：基准值
	- `SEEK_SET` ： 从文件头开始，此时offset必须>=0
	- `SEEK_CUR`  :   从当前位置开始
	- `SEEK_END`：  从文件末尾开始    此时offset<=0

使用场景
- 随机读取

```c
FILE *fp = fopen("bin.data", "rb");
// 移动到文件第100字节位置（从开头算）
fseek(fp, 100, SEEK_SET);
// 读取该位置的数据
int data;
fread(&data, sizeof(int), 1, fp);

// 从当前位置向后移动20字节
fseek(fp, 20, SEEK_CUR);

// 移动到文件末尾前50字节
fseek(fp, -50, SEEK_END);
fclose(fp);
```

## 5.6 ftell()

```c
long ftell( FILE* stream );
```

返回文件流`stream`当前位置相对于文件开头的字节偏移量  （-1 代表是失败）

使用场景
- 记录当前位置，以便后续恢复
- 计算文件大小

```c
FILE *fp = fopen("file.txt", "r");
// 获取文件大小
fseek(fp, 0, SEEK_END);
long size = ftell(fp);  // size 为文件总字节数

// 记录当前位置并恢复
long pos = ftell(fp);   // 记录末尾位置
fseek(fp, 0, SEEK_SET); // 移动到开头
// ... 处理数据 ...
fseek(fp, pos, SEEK_SET); // 恢复到之前记录的位置
fclose(fp);
```

## 5.7 fflush()

```c
int fflush(FILE *stream);
```

将文件流`stream`的缓冲区的数据立即写入到实际文件，或者丢弃输入缓冲区数据

使用场景
- 确保数据及时写入磁盘（日志记录、关键的数据等）
- 多进程/线程操作同一个文件时，避免缓冲区数据不一致

```c
FILE *fp = fopen("log.txt", "a");
fprintf(fp, "操作日志：xxx\n");
fflush(fp);  // 立即将日志写入文件，避免程序意外退出时丢失
// ... 后续操作 ...
fclose(fp);  // fclose 会自动刷新缓冲区，无需手动调用
```