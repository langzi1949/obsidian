
# 1. 和C语言中的指针比较

C++的指针在**核心机制以及内存表示上**和C语言是相同的，因为C++继承了C语言的底层内存模型。
## 1.1  核心机制的相同点
- **内存地址** ： 指针本质上就是存储内存地址的变量，在32位机器上占用固定大小的内存（4个字节），64位上则是8个字节
- **解引用**  都是通过`*`运算符解引用指针以访问它指向的值
- **取地址**   都是通过`&`运算符获取变量的地址
- **指针运算**  相同的逻辑，加减运算都是基于指针类型的大小进行移动
- **void指针**    `void*` 在两种语言中都是用于存储任何数据类型的地址，但是在C++中不能直接解引用，需要类型转换

## 1.2 关键区别

C++对指针的使用有更加严格的限制或者引入了更加现代的替代品，以提高代码的安全性和表达力。

1. 严格的类型检查

C： 允许将`void*`隐式的转换为任何其他数据类型的指针

```c
int* ip = malloc(sizeof(int));
char* cp = ip; // ❌ C语言会警告，但许多编译器可能允许
void* vp = ip;
char* cp2 = vp; // ✅ C语言允许隐式转换
```

C++： 不允许将`void*`隐式转换为其他指针类型。所有指针类型之间的转换都需要显式的类型转换

```cpp
int* ip = new int;
void* vp = ip;
char* cp2 = static_cast<char*>(vp); // ✅ 必须使用显式转换
char* cp3 = vp; // ❌ C++ 编译错误
```

## 1.3 空指针

C正常来说，空指针用`NULL`来表示
但是C++11后，引入了`nullptr`关键字，这个**专用的空指针常量**，具有强类型安全，能够有效的避免`NULL`和整数`0`之间的歧义问题。现代C++开发，强烈建议使用`nullptr`

## 1.4 指针的危险

```cpp
int *p;
*p = 10;
```

这个代码是非常危险的，虽然我们可能侥幸能够正常运行，但是危害很大
- `*p` 没有指向明确的地址，虽然可能`*p= 10`能够成功，但是有很大概率是不成功的，它随机指向的那个地址可能是只读的，怎么办呢？就会出现崩溃异常的。
- <span class="r" style="font-size:20px;background-color:yellow">在指针使用的时候，一定要给指针初始化一个确定的、适当的地址</span>

# 2. 