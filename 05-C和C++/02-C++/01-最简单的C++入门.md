#cpp

# 1. 简单的给C++下一个定义

<span class="b">C + OOP + 泛型 + 模板  = C++</span>

从上面的公式就能够得出来，C++相对于C来说，主要的拓展和衍生
- **OOP**   ：面向对象的编程范式
- **泛型**   ： 一种思想范式，目标是编写与类型无关的通用代码，不能为了不同的类型实现相同逻辑的代码
- **模板**  ： 在C++中是实现 `泛型`的工具或者机制，它是语法工具，包含==函数模板==和==类模板==

# 2. main函数需要要写return吗？

答案是不需要的，只有在main函数中这种情况才成立。

```cpp
int main(void)
{
	// statements语句
}
```

以上不写 `return 0;` 也是可以的，这个是C++标准做出的一个妥协，但是其他函数如果有返回值，必须要要写return

# 3. namespace的使用

- 直接在函数体外部，相当于全局使用`using namesapce std`
- 在使用到的地方引用，比如在某个函数体内

```c
int prin()
{
	using namespace std;
	cout << "xxxxx" << endl;
	return 1;
}
```

- 没有必要引入整个`std`，可以按需引入 `using std::cout`

```cpp
int main(void)
{
    using std::cout;
    cout << "Hello\n";
    return 0;
}
```

- 不引用`std`， 直接使用

```cpp
int main(void)
{
    std::cout << "Hello\n";
    return 0;
}
```

> [!danger]
> 为啥`<<`可以用于输出流呢？
> 答案就是 C++的运算符重载

# 4. C++程序的模块叫啥

- **最传统的答案**： 头文件 + 源文件
- **最现代的答案**：模块 （C++20标准开始的）
- **最常用于逻辑组织的**： 命名空间 namespace


# 5. C和C++的基本类型相同吗？

首先，C语言中的所有的基本类型，在C++中必然是可以用的。
比如 `int`  `short` `int` `long` `long long`  `float` `double` `long double`

C++独有的基本类型
- `bool`   虽然C99之后有相关的bool类型了，但是不够方便，现在bool在C++中是内置的基本类型，有true和false
- `wchar_t`  宽字符串类型， 用于支持国际字符集
- `引用类型` 这个不是基本类型，但是通过`&`进行引用，对现有变量的一种别名
- `void*` 需要进行显式转换

# 6. C++11提供的初始化

正常我们的代码初始化是`int a = 23;` 但是在C++11之后有一个很诡异的方式：**列表初始化或者统一初始化**

```cpp
int variable = {};
int pyP{8};
```

| 语法  | 示例         | 使用类型           |
| --- | ---------- | -------------- |
| 圆括号 | int p(8);  | 基本类型，类似调用构造函数  |
| 等号  | int p = 8; | 基本类型，我们最常见的初始化 |
| 列表  | int p{8};  | **通用**，适用于所有类型 |
使用列表初始化最大的好处就是 <span class="r">安全</span>
不会进行隐式的转换
```cpp
int a = 3.14;  // 最终a就是3，数据精度丢失
int a{3.14};   // 这个是直接编译错误，因为double到int可能精度丢失，编译器不允许这么干
```

# 7. wchar_t、char16_t、char32_t

以上都是处理扩展字符集和国际化而引入的类型，它们旨在解决标准char类型无法表达的字符的问题。

- `wchar_t`  不具有固定的大小和编码，在16位上用于UTF-16编码
- `char16_t`  保证至少16位大小的无符号整数类型， 专门设计用于存储Unicode的UTF-16编码单元
- `char32_t`  保证至少32位大小的无符号整数类型， 专门设计用于存储Unicode的UTF-32编码单元

```cpp
wchar_t a = L'P';
char32_t b = U'U';
char c = 'A';
std::cout << a << std::endl;  // 80
std::cout << b << std::endl;  // 85
std::cout << c << std::endl;  // A
```

为啥`wchar_t`和`char32_t` 这个输出是数字呢？ 那是因为它们的类型底层的逻辑就是数值类型


# 8. 拼接字符串常量

```cpp
char *str1 = "h"
			 "s"
			 "sssdfsdsdfsdf";
```

# 9. C++中字符串

- C-风格的字符串

```cpp
char str[20] = "xxxxxxx";
char str[20] = {'x','s','a','\0'}  // 最后必须要有\0
char *str = "xxxxxx";
```

- string类的使用

```cpp
#include <string>
string str;  // 一个空的字符串
string str = "zmglove";
```

同时，C++11过后支持 列表初始化方式来初始化字符串

```cpp
// 以下4种都是正确的，别惊讶
char str[] = {"hello"};
char str[]{"hello"};
string str = {"hello"};
string str{"hello"};
```



# 10. cin的一系列问题

## 10.1  字符串输入

```cpp
#include <iostream>
using namespace std;

/**
 * 来自 C++ primer plus Page 77
 */
int main(void)
{
    const int SIZE = 20;
    char name[SIZE];
    char dessert[SIZE];

    cout << "Enter your name:\n";
    cin >> name;
    cout << "Enter your favourite dessert: \n";
    cin >> dessert;
    cout << "I have some delicious " << dessert;
    cout << " for you," << name << ".\n";
    return 0;
}
```

以上的代码在输入`name`的时候，如果是`zmg love`  这种有空格的的话，最终等不到`Enter your favourite dessert`的输入信息，就运行完毕了
![[Pasted image 20251022135827.png\|600]]
那么`cin`是如何确定已完成字符串的输入的呢？

- 首先，cin无法处理包含空格的输入。 这个是cin的核心缺陷。 C++中`>>` 默认会将空格（以及Tab、换行符等）视为分隔符。
- 导致输入`zmg love` 最终cin只会读取第一个`zmg`。 `love`会留在输入缓冲区，等到`Enter your favouriate dessert`的时候，我们来不及输入，会将缓冲区中的`love`赋值给`dessert`。
- 同时`cin`还有一个问题就是，字符串的size只有20，如果我们输入超过20个字符的话，程序就会报错崩溃，不够安全

## 10.2 面向行的输入  getline()

将上面的代码稍加改一下，就能够满足输入带有空格的字符串了

```cpp hl:11
#include <iostream>
using namespace std;

int main(void)
{
    const int SIZE = 20;
    char name[SIZE];
    char dessert[SIZE];

    cout << "Enter your name:\n";
    cin.getline(name, SIZE);
    cout << "Enter your favorite dessert:\n";
    cin.getline(dessert, SIZE);
    cout << "I have some delicious " << dessert;
    cout << " for you, " << name << ".\n";
    return 0;
}
```


## 10.3 面向行的输入 get()

`iostream`里面有另外一个`get()`函数，该函数有几个变体：
- cin.get(name, SIZE);   这个有问题， 第一个输入没有问题，它会读取整行的数据，但是遇到换行符，不会舍弃，会将换行符一直留在缓冲区，那么第二个`cin.get(dessert, SIZE);` 这个就有问题了，会直接读取一个换行符，它认为到行尾了，所以dessert会是一个空字符串。
- <span class="r">好在get()还有另外一个变体</span>
- 不带任何参数的`cin.get()`调用，可以读取下一个字符（即使是换行符），相当于在缓冲区中将换行符先读出去

```cpp hl:2
cout << "Enter your name:\n";
cin.get(name, SIZE).get();
cout << "Enter your favorite dessert:\n";
cin.get(dessert, SIZE).get();
cout << "I have some delicious " << dessert;
cout << " for you, " << name << ".\n";
return 0;
```

## 10.4 混合输入字符串和数字

```cpp
#include <iostream>
using namespace std;

int main(void)
{
    cout << "What year was your house built?" << endl;
    int year;
    cin >> year;
    cout << "What is its street address?" << endl;
    char address[80];
    cin.getline(address, 80);
    cout << "Year built : " << year << endl;
    cout << "Address : " << address << endl;
    cout << "DONE!!" << endl;

    return 0;
}
```

你会发现输入 year 的值，比如1996后，程序直接顺利运行结束了，没有机会输入address。同样的是因为会有一个换行符在缓冲区中，等到`cin.getline()`的时候，直接读取了缓冲区的数据了，导致address是空字符串
那么如何解决呢？ 和上面的`10.3`一样，将缓冲的数据先输出。

```cpp
cin >> year;
cin.get();  // 先将换行符读取了

// 或者用这个方式
(cin >> year).get();
```



