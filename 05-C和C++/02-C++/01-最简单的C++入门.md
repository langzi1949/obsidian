#cpp

# 1. 简单的给C++下一个定义

<span class="b">C + OOP + 泛型 + 模板  = C++</span>

从上面的公式就能够得出来，C++相对于C来说，主要的拓展和衍生
- **OOP**   ：面向对象的编程范式
- **泛型**   ： 一种思想范式，目标是编写与类型无关的通用代码，不能为了不同的类型实现相同逻辑的代码
- **模板**  ： 在C++中是实现 `泛型`的工具或者机制，它是语法工具，包含==函数模板==和==类模板==

# 2. main函数需要要写return吗？

答案是不需要的，只有在main函数中这种情况才成立。

```cpp
int main(void)
{
	// statements语句
}
```

以上不写 `return 0;` 也是可以的，这个是C++标准做出的一个妥协，但是其他函数如果有返回值，必须要要写return

# 3. namespace的使用

- 直接在函数体外部，相当于全局使用`using namesapce std`
- 在使用到的地方引用，比如在某个函数体内

```c
int prin()
{
	using namespace std;
	cout << "xxxxx" << endl;
	return 1;
}
```

- 没有必要引入整个`std`，可以按需引入 `using std::cout`

```cpp
int main(void)
{
    using std::cout;
    cout << "Hello\n";
    return 0;
}
```

- 不引用`std`， 直接使用

```cpp
int main(void)
{
    std::cout << "Hello\n";
    return 0;
}
```

> [!danger]
> 为啥`<<`可以用于输出流呢？
> 答案就是 C++的运算符重载

# 4. C++程序的模块叫啥

- **最传统的答案**： 头文件 + 源文件
- **最现代的答案**：模块 （C++20标准开始的）
- **最常用于逻辑组织的**： 命名空间 namespace


# 5. C和C++的基本类型相同吗？

首先，C语言中的所有的基本类型，在C++中必然是可以用的。
比如 `int`  `short` `int` `long` `long long`  `float` `double` `long double`

C++独有的基本类型
- `bool`   虽然C99之后有相关的bool类型了，但是不够方便，现在bool在C++中是内置的基本类型，有true和false
- `wchar_t`  宽字符串类型， 用于支持国际字符集
- `引用类型` 这个不是基本类型，但是通过`&`进行引用，对现有变量的一种别名
- `void*` 需要进行显式转换

# 6. C++11提供的初始化

正常我们的代码初始化是`int a = 23;` 但是在C++11之后有一个很诡异的方式：**列表初始化或者统一初始化**

```cpp
int variable = {};
int pyP{8};
```

| 语法  | 示例         | 使用类型           |
| --- | ---------- | -------------- |
| 圆括号 | int p(8);  | 基本类型，类似调用构造函数  |
| 等号  | int p = 8; | 基本类型，我们最常见的初始化 |
| 列表  | int p{8};  | **通用**，适用于所有类型 |
使用列表初始化最大的好处就是 <span class="r">安全</span>
不会进行隐式的转换
```cpp
int a = 3.14;  // 最终a就是3，数据精度丢失
int a{3.14};   // 这个是直接编译错误，因为double到int可能精度丢失，编译器不允许这么干
```

# 7. wchar_t、char16_t、char32_t

以上都是处理扩展字符集和国际化而引入的类型，它们旨在解决标准char类型无法表达的字符的问题。

- `wchar_t`  不具有固定的大小和编码，在16位上用于UTF-16编码
- `char16_t`  保证至少16位大小的无符号整数类型， 专门设计用于存储Unicode的UTF-16编码单元
- `char32_t`  保证至少32位大小的无符号整数类型， 专门设计用于存储Unicode的UTF-32编码单元

```cpp
wchar_t a = L'P';
char32_t b = U'U';
char c = 'A';
std::cout << a << std::endl;  // 80
std::cout << b << std::endl;  // 85
std::cout << c << std::endl;  // A
```

为啥`wchar_t`和`char32_t` 这个输出是数字呢？ 那是因为它们的类型底层的逻辑就是数值类型


