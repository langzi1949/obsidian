
# 1. 计算机中的整数数值都是用补码存储的？

为什么计算机中的整数都是用补码存储的呢？ 首先我们搞懂什么是反码，以及原码和补码？
无论是原码、反码或者补码？ 最高位都是符号位：
- 0      代表是正数
- 1       代表是负数

## 1.1 正数

正数的原码、反码以及补码 三者都是相同的，是最简单的。
比如： 21  （以8位为例）
原码 ： 00010101    
反码：  00010101
补码：  00010101

它们三码都是一样的

## 1.2 负数

负数的三码都不一样，需要计算获得
比如： -21  （同样以8位为例）

<span class="b">原码计算逻辑 ：</span>
- 先取`-21`的绝对值为21
- 求21的原码
- 最后高位调整成`1`

所以，-21的原码就是  10010101

<span class="b">反码的计算逻辑：</sapn>
- 在原码的基础上，除了最高位，其余取反，1->0  , 0->1

所以， -21的反码就是  11101010

<span class="b">补码的计算逻辑：</span>
- 在反码的基础上 + 1， 保证最高位是1

所以，-21的补码就是 11101011

>[!danger]
>关于0的特殊性，可以将其看为 +0 和-0

## 1.3 为啥用补码存储数值？

主要是为了实现硬件上的简化和统一。

- 消除了减法运算。 CPU只有加法器，因为可以将a-b 转化为 a+(-b)
- 补码对0的唯一表达， 因为+0的原码、反码和-0的原码、反码是不一样的，只有补码是相同的，减少了复杂性
- 补码表示的范围广。对于一个 N 位的整数，补码能够表示的负数比正数多一个，可以表示的范围是 $[-2^{N-1}, 2^{N-1} - 1]$

# 2. 浮点数是如何存储？

浮点数跟整数不一样，它不是用补码来存储的，而是基于一套国际规则- **IEEE 754 标准**
根据IEEE 754标准，一个浮点数被拆分成三个主要部分存储在一个固定宽度的内存块中（例如，`float` 占 32 位，`double` 占 64 位)
它相对比较复杂，暂时不用学习了

# 3. 大端和小端的字节序

这个和编程语言没有关系，是硬件存储的数据的一种方式。
- 只针对多字节的数据，比如char这种一个字节的就谈不上字节序了
- 分为**大端字节序**和**小端字节序**， 是按照字节来拆分，一个字节就是8位。

首先理解一下 高位和低位
我们正常举例子，用一个int型数据来表示 `0x11223344`  这样的一个16进制数据表达32位的数据，最终存储在内存中依然是二进制，只是用16进制好表达。
`0x11223344`
高位字节序 ->  0x11
低位字节序 ->  0x44

在内存中，我们我们把地址区分为从低到高。

![[Pasted image 20251005212925.png|\300]]

1. 小端字节序：
	1. 将低位字节放在低地址，高位字节放在高地址，  类似反着放一样
	2. 几乎所有的个人电脑的CPU都是采用小端字节序存储

----


![[Pasted image 20251005213326.png]]

2. 大端字节序
	1. 将高位字节放在低地址，低位字节放在高地址，就是正着放的感觉
	2. 主要用在网络传输上，所有的TCP/UDP都是采用大端字节序存储，这种就称为『网络字节序』

正常情况下，我们不用关注大小端的问题，只有不同的字节序存储的机器进行通信的时候，需要进行转换才可以使用。

> [!info]
> 为啥TCP传输是用大端字节序？
> 1. 首先是由国际组织进行统一标准的，大家都按照同一个标准来
> 2. 大端符合直觉，同时方便抓包的时候得到的字节序就是正常的，有利于排查问题

> [!question]
> Q: 写一个程序来判断当前环境是大端还是小端？
> A：用C语言写一个程序，int a = 1;    因为1 存储是  0x00000001   如果是小端的话，那么&a 指向的就是0x01， 如果是大端就是指向0x00。 但是`*a`取值的话，是按照类型取值的，会取出整个4个字节的数据； 有没有什么办法只取出一个字节呢？  将 &a强制转为`char*`  这样就代表是一个字节

```c
int main(void)
{
    int a = 1;
    if (*(char *)&a == 1)
    {
        printf("小端");
    }
    else
    {
        printf("大端");
    }
    return 0;
}
```

或者使用union的方式，因为union的成员共用一个内存地址

```c
int check()
{
    union Un
    {
        char i;
        int j;
    } un;
    un.j = 1;
    return un.i;
}

// 如果返回1 就是小端
```

