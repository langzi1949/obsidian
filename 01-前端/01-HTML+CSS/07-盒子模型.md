#前端 #CSS #盒子模型

> 本文将的是CSS的盒子模型相关的知识点


# 概述

盒模型是理解和掌握`CSS`布局的基石，极其重要！

在`CSS`中，每个HTML元素都被视为一个矩形的盒子。这个盒子由4个部分组成，从内到外分别是：
1. **内容区域（Content Box）：**
    - **作用：** 这是放置元素**实际内容**的区域，比如文本、图片或其他嵌套的元素。
    - **大小：** 由 `width` 和 `height` 属性（或由内容撑开）决定。        
2. **内边距（Padding Box）：**
    - **作用：** 包围着内容区域，是**内容和边框之间的空间**。
    - **特性：** `padding` 具有背景色（会继承内容的背景色）。
    - **大小：** 由 `padding` 属性（`padding-top`, `padding-right`, `padding-bottom`, `padding-left`）决定。
3. **边框（Border Box）：**
    - **作用：** 包围着内边距和内容区域，是**盒子的边框**。
    - **特性：** `border` 有宽度、样式和颜色。
    - **大小：** 由 `border` 属性（`border-width`, `border-style`, `border-color`）决定。
4. **外边距（Margin Box）：**
    - **作用：** 包围着边框，是**盒子与其他元素之间的空间**。
    - **特性：** `margin` 是透明的，它**不**具有背景色。外边距会影响元素在页面上的实际占用空间，但不是元素自身的一部分。
    - **大小：** 由 `margin` 属性（`margin-top`, `margin-right`, `margin-bottom`, `margin-left`）决定 


![[Pasted image 20250706084112.png]]

# 两种盒模型类型

## `content-box`   W3C标准模型/默认模型

> 特点就是： 当设置一个元素的`width`和`height`时，这两个值只会控制`content-box`的大小
> 
> `padding`和`border`的宽度会额外增加元素的总尺寸
> 
> `最终的总宽度`  = `width` + `padding-left` + `padding-right` + `border-left-width` + `border-right-width`
> 
> `最终的总高度` = `height` + `padding-top` + `padding-bottom` + `border-top-width` + `border-bottom-width`

> [!DANGER]
> 需要注意的是此模型在计算宽高的时候进行出错

## `border-box` (替代盒模型)

> 特点就是： 当你设置一个元素的 `width` 和 `height` 时，这两个值**包括了内容区域、内边距（padding）和边框（border）** 的总和。
> 
> `padding` 和 `border` 的宽度会**向内挤压**内容区域，而不会增加元素的总尺寸
> 
> **总宽度 = `width`** (因为 `width` 已经包含了 `padding` 和 `border`)
> 
> **总宽度 = `width`** (因为 `width` 已经包含了 `padding` 和 `border`)
> 
 
> [!INFO] 
> 此模式更加符合直觉、更容易计算布局。所以在现代前端开发中，强烈推荐采用`border-box`盒模型

```css
/* 设置所有元素和伪元素的盒模型为 border-box */
html {
  box-sizing: border-box;
}
*, *::before, *::after {
  box-sizing: inherit; /* 继承 html 元素的 box-sizing 值 */
}
```



# 设置padding的大小

### 复合属性：

```css
/* 应用于所有边 */
padding: 1em;

/* 上边下边 | 左边右边 */
padding: 5% 10%;

/* 上边 | 左边右边 | 下边 */
padding: 1em 2em 2em;

/* 上边 | 右边 | 下边 | 左边 */
padding: 5px 1em 0 2em;

/* 全局值 */
padding: inherit;
padding: initial;
padding: revert;
padding: revert-layer;
padding: unset;

```


### 单独的属性
- [`padding-top`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-top)
- [`padding-right`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-right)
- [`padding-bottom`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-bottom)
- [`padding-left`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding-left)

# border的设置

border要想生效显示必须同时定义 ==border-width==、==border-style==、==border-color==

# margin的使用

| CSS属性名 <img width = "200"> | 作用                                 |
| -------------------------- | ---------------------------------- |
| `margin-left`              | 左外边距                               |
| `margin-right`             | 右外边距                               |
| `margin-top`               | 上外边距                               |
| `margin-bottom`            | 下外边距                               |
| `margin`                   | 复合属性，可以写`1 ~ 4`个值，规律同`padding 顺时针` |

> [!Danger]
> - 子元素的`margin`，是参考父元素的`content box`计算的
> - `上margin`、`左margin`：影响自己的位置；`下margin`、`右margin`：影响后面兄弟元素的位置
> - ==块级元素==、==行内块元素==，都可以设置四个方向的margin；但是==行内元素==，只能设置左右margin，上下margin设置无效
> - margin的值也可以是auto，如果给一个==块级元素==设置左右margin都为auto，该块级元素会在父元素水平居中
> - margin的值可以是负数



# margin的塌陷问题

> [!tips]
> 首先注意，`margin`的塌陷只会发生在`垂直方向`，即`margin-top`、`margin-bottom`，水平方向不受影响

有三个主要的情况会发生margin坍塌

1. ==相邻兄弟元素的外边框塌陷==

```html
<div class="box1">Box 1</div>
<div class="box2">Box 2</div>
```

```css
.box1 {
  margin-bottom: 20px;
  background-color: lightblue;
}
.box2 {
  margin-top: 30px; /* 实际盒子之间只有 30px 间距，而不是 20px + 30px = 50px */
  background-color: lightcoral;
}
```

> 最终，`Box1`和`Box2`之间的垂直减去是`30px`（取`20px`和`30px`中的最大值）

> [!answer]
> 解决办法：
> - 在父元素设置Flex容器或者Grid布局   `display: flex` 或者`display: grid`

> 
2. ==父元素与其第一个或者最后一个子元素的外边框塌陷，他们最终会作用在父元素上==

```html
<div class="parent">
  <div class="child">Child Content</div>
</div>
```

```css
.parent {
  background-color: lightgreen;
  margin-top: 40px; /* 父元素的顶部外边距 */
}
.child {
  background-color: lightgoldenrodyellow;
  margin-top: 20px; /* 子元素的顶部外边距 */
}
```

> [!answer]
> 解决此问题的方案：
> - 给父元素设置border或者设置padding。这样就是为了将父元素和子元素的外边距之间创建屏障
> - 给父元素添加`overflow: hidden`  创建BFC，阻止塌陷，但是可能会裁剪内容，慎用
> - 给父元素设置`display: flow-root` 同样创建BFC，但是不会裁剪内容，优先使用
> - 父元素设置Flexbox或者Grid布局  `display: flex` 或者`display: grid`
> 

3. ==空块级元素的外边框塌陷==

> [!answer]
> 解决办法：
> - 添加`border` 
> - 添加`padding`
> - 添加任何内容
> - 设置`height`或者`min-height`
> - 创建BFC 比如： `overflow: hidden` 或者 `display: flow-root`


