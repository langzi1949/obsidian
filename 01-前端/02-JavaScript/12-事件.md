#前端 #JavaScript #JS  #事件


JavaScript与HTML的交互是通过**事件**来实现的。

# 1. 事件类型

1. 用户界面事件
2. 焦点事件
3. 鼠标事件
4. 滚轮事件
5. 输入事件
6. 键盘事件


> [!danger]
> 重点理解一下，冒泡的概念，有些事件是支持冒泡，有的不支持，那么什么是冒泡呢？
> 事件冒泡指的是，当一个事件在一个元素上被触发后，它会首先在该元素上执行其对应的事件处理函数（如果有的话），然后这个事件会沿着 DOM 树向上传播，依次触发其父元素、祖父元素，直到 document 对象，最终到达 window 对象。
> 正常的事件都支持冒泡，但是一般跟特定元素或者窗口本身有关的事件有部分不支持冒泡，比如`focus、blur`等



# 2. 用户界面事件

最常用的有2个左右， `load`、`unload`
## 2.1 load事件

load事件是JS中最常用的事件。在window对象上，load事件在整个页面，包括外部资源如图片、js和css文件都加载完成后触发

```js
// 方法1
window.onload  = (){};
// 方法2
window.addEventListener('load', ()=> {});
```

> [!tips]
> 注意，上面的方式1是采用的DOM 0级事件，所有的逻辑都是`on`+事件名称
> 但是现代开发规范中，建议采用方式2：`window.addEventListener('load', () => {})`

针对load事件，绝大数情况下，更加推荐使用
```js
document.addEventListener('DOMContentLoaded', () => {});
```
DOMContentLoaded 不需要等外部依赖的css和js都加载完毕才触发，而是在HTML文档完全加载和解析完成后，就触发了，这样会有效的提升交互效率和用户等待事件。
除非，内部的处理依赖加载后的css的信息等，所以推荐使用`DOMContentLoaded`

## 2.2 unload事件

与`load`事件相对，`unload`事件会在文档卸载完成前触发，比如从一个页面到另外一个页面时触发。作用一般就是清理一些引用，防止内存泄露

# 3.  焦点事件

最常见的就是 文本输入框，获取焦点的时候会触发一些事件等。

- focus    当元素获得焦点的时候触发，此事件不冒泡
- blur   当元素失去焦点的时候触发，此事件不冒泡
- focusin    当元素获得焦点时触发， 支持冒泡
- focusout   当元素失去焦点时触发， 支持冒泡

# 4. 鼠标和滚轮事件

- click   鼠标点击 或者键盘回车时触发
- dblclick   双击触发
- mousedown    任意鼠标键按下就触发
- mouseenter     鼠标光标从元素外移到元素内时触发    **不冒泡，也不会在光标经过后代元素时触发**
- mouseleave     鼠标光标从内部移到元素外时触发        **不冒泡，也不会在光标经过后代元素时触发**
- mousemove     鼠标光标在元素上移动时反复触发
- mouseout         鼠标从一个元素到另一个元素上时触发，移动的元素可以从父元素到子元素，也会触发
- mouseover     和mouseout类似，但是是反过来，从另外的元素到元素内部时候触发，可以是从子元素到父元素的时候，也会触发
- mouseup    用户释放鼠标键的时候出发

## 4.1 鼠标的位置坐标

鼠标的坐标，可以用 (clientX, clientY)表达。  这个信息被保存在event对象上，所以应该用event去获取属性信息

```js
let div = document.getElementById('#id');
div.addEventListener('click', (event) => {
	console.log(event.clientX, event.clientY);
})
```


# 5. JS中绑定事件的三种方式

## 5.1 使用`addEventListener`的方式

```js
let div = document.getElementById('#id');
div.addEventListener('click', (event) => {
	console.log(event.clientX, event.clientY);
})
```

# 5.2 采用0级事件方式

```js
let div = document.getElementById('#id');
div.onclick = (event) => {
  console.log(event.clientX, event.clientY);
}
```

## 5.3 内联方式

```html
<div id = "id" onclick="console.log(event.clientX, event.clientY);">
</div>
```

# 6.  event.currentTarget或者event.target

对于箭头函数，我们想回调的时候，获取到绑定事件监听器的元素，应该怎么办呢？

- 普通的匿名函数  function() {}  这种方式里面的this就是监听器的元素
- 但是箭头函数 () => {}  里面的this就不是监听器的元素，而是定义这个箭头函数时候的上下文，一般是window

那么在箭头函数中如何获取监听器的那个元素呢？

箭头函数可以接收一个`event`参数，通过**event中的currentTarget或者target**来获取

- event.currentTarget ： 总是指向绑定事件监听器的元素
- event.target：  指向实际触发事件的元素

```js
$('#btn2').click((event) => {
  // `event` 是事件对象
  // `event.currentTarget` 指向绑定事件的元素
  console.log(event.currentTarget); // 输出: <button id="btn2">...</button>

  // 你可以像使用 `$(this)` 一样使用 `$(event.currentTarget)`
  const buttonText = $(event.currentTarget).text();
  console.log('按钮文本是:', buttonText);

  const username = $('#username').val();
  console.log('用户名是:', username);
});
```

# 7. 删除事件

原生的没有删除所有事件的方法，最常见的方式就是克隆元素代替它。

删除特定事件，用`removeEventListener()`, 并且要提供与添加时完全相同的事件类型和函数引用，不能用匿名函数

```js
function handler() {}
const button = document.getElementById('id');
button.addEventListener('click', handler);

// 删除
button.removeEventListener('click', handler);  // 第二个参数必须和添加的那个函数是同一个

/*如果是匿名函数，将没有效果*/
button.addEventListener('click', () => {});
button.removeEventListener('click', () => {}); // 这个没有任何效果，是无效的代码 
```

# 8. 事件委托

核心思想：**将子元素的事件监听器，绑定到它们的父元素上**

当子元素上的事件被触发时，该事件会沿着 DOM 树向上传播（这个过程叫事件冒泡），直到被父元素上绑定的监听器捕获。然后，我们再根据事件对象（event object）来判断是哪个子元素触发了事件，并执行相应的处理逻辑。

## 8.1 为什么需要事件委托？
* 性能优化： 如果一个列表有1000个`<li>`元素，与其给每个元素都添加点击事件，不如给他们的共同父元素添加事件
* 动态元素：对于那些在页面加载后通过JS动态添加的元素，如果使用事件委托，无需为每个新元素绑定事件，他们自然继承父元素的处理事件
## 8.2 如何实现事件委托？

核心的逻辑：
- 事件冒泡
- event对象

```js
// 1. 在父类元素上绑定事件
button.addEventListener('click', (event) => {
	//  2. 通过event.target判断哪个子元素被点击
	const elem = event.target;
    if (elem.tagName === 'LI') {
	// 3. 执行逻辑
	//......
    }
})
```

# 9. 阻止事件的默认行为

在浏览器中，很多元素在被触发时都有一个预设的、默认的动作。`event.preventDefault()` 就是一个方法，用来告诉浏览器：“嘿，别执行你的默认动作，我来处理这个事件。”

```html hl:11
<form id="myForm">
  <input type="text" />
  <button type="submit">提交</button>
</form>

<script>
  const form = document.getElementById('myForm');

  form.addEventListener('submit', function (event) {
    // 阻止表单提交的默认行为（页面刷新）
    event.preventDefault(); 

    // 在这里执行你的自定义逻辑，比如：
    console.log('表单被提交了，但页面没有刷新！');
    // 发送 AJAX 请求...
  });
</script>
```



