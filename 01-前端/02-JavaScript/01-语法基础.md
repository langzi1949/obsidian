#前端 #JavaScript #JS 

> 本文讲一下JavaScript的基础 （语法、变量）

# 语法

- 区分大小写
- 标识符： 第一个字符必须是字母、下划线或者美元符号，命名方式和Java一样，都是驼峰风格
- 当前现代JS的开发中，推荐使用`严格模式` , 在脚本开头添加`use strict`
- 正常来说语句默认都要添加分号`;`，但是省略分号的话解析器也可以工作，但不太推荐

# 变量

有三个关键字可以声明变量 ： `var`、`const`、`let`

### var

1. var的声明作用域在整个**函数内部**或者**全局作用域**
```js
function test() {
	var message = "hi"; // 局部变量
}
test();
console.log(message); // 出错！  ReferenceError: message is not defined
```

> [!dangers]
> - 需要注意很诡异的事情，如果在test()中，不用`var`去声明变量，那么这个变量就变成了==全局变量==，不推荐使用
> - 可以通过`var`定义多个变量，类似Java中的语法`var msg = "hi", fount = false;`

2. var的声明提升
在使用`var`时，会将这个关键字声明的变量自动提升到函数作用域顶部
```js
function test() {
	console.log(message);
	var message = 'hi';
}
test();  // 不会出错，会输出 undefined

/*以上代码就相当于*/
function test() {
	var message;  // 提升了，初始化成undefined
	console.log(message);
	message = 'hi';
}
test();
```

3.  允许重复声明，同时允许重复赋值

### let

1. let声明的范围是 ==块作用域==
```js
function test() {
	if (true) {
		let age = 24;
		console.log(age);  // 正常输出
	}
	console.log(age);  // 直接报错，ReferenceError
}
test();
```
 age这个变量的作用范围只在`if`代码块中，出了块就无法访问了

2.  let同样会提升，但是并没有初始化，会存放在`暂时性死区` （temporal dead zone, TDZ）
```js
function test() {
	if (true) {
		console.log(age); // 会报错，ReferenceError: Cannot access 'age' before initialization
		let age = 24;  
	}
}
test();
```

3. let不允许重复声明，但是可以重复赋值

### const

`const`和`let`几乎相同，只有一点： `const`不允许重复赋值，因为这儿被认为是一个常量或者不变的量

### 最佳实践
1. 尽量不使用`var`
2. `const`优先，`let`次之


# 数据类型（7种基本类型）

- `undefined` 表示值未定义
- `boolean`  
- `string`
- `number`
- `object`  表示对象(并不是函数)或者null
- `function`  表示是函数
- `symbol` 表示是符号

```js
let message = "hello";
console.log(typeof message);
console.log(typeof(message));
```

### boolean类型
一般非boolean类型的值，会在`if`条件中自动转为boolean类型，具体的逻辑就符合常识就行

### 数值类型转换

- Number()
- parseInt()
- parseFloat()

#### Number()
- boolean  true -> 1, false -> 0
- 数值直接返回
- null 返回0
- undefined 返回NaN
- 字符串
	- ✅ 只包含数值或者数值前加上0或者正负号，则可以正常转换，比如 Number("1234")  Number("-3243")
	- ✅ 如果是有效的浮点格式，也可以正常转化
	- ✅ 如果是有效的十六进制格式，比如"0xf" ，也能正常转换，转为十进制
	- ✅ 空字符串 ，返回0
	- ❌ 以上都不符合，返回NaN
- 对象： 先调用对象的valueOf()，如果不行，继续调用toString()，继续上面字符串的规则进行转换

#### parseInt()

正常直接使用`parseInt()`方法就行了，但是他的规则和Number稍微有点不一样
- 空字符串 返回NaN
- "1232abc" 返回1232 (必须是数字开头，知道结尾或者第一个非数字字符为止，其后都会忽略)
- "bsdf1234" 返回NaN

### String类型
字符串可以使用双引号`"`，单引号`'`或者反引号 将其包裹表示。其中反引号的作用是支持多行字符串。
同样的反引号的字符串，可以进行字符串模板方法
```js
let value = 23;
let message = `value = ${value}`;  // 模板方法，可以不采用字符串加号拼接
```

所有字符串模板的逻辑，其实就是对插入的值调用了toString()方法，强制转换为字符串。

### 字符串模板字面量标签函数

```js
let a = 6;
let b = 9;
function st(strings, aval, bval, sum) {
	console.log(strings);
	console.log(aval);
	console.log(bval);
	console.log(sum);
	return 'foobar';
}
let value = `${a} + ${b} = ${a + b}`;
let tr = st`${a}+${b}=${a + b}.`;   // 这个就是标签函数
console.log(value);
console.log(tr);
```

工作流程就是：
接收的参数有两部分
1. 字符串数组： 就是strings, 模板字面量中所有不包含插值表达式的原始字符串组成一个字符串数组
2. 表达式值 (...values)  其实就是将字面量中插值表达式求值后的结果，按顺序放到对应的可变参数中
所以上面的代码可以调整成
```js
function st(strings, ...values) {
	console.log(strings);
	for (const v of values) {
		console.log(v);
	}
	return 'foobar';
}
```

### Symbol类型

这个是ES6新增的数据类型，表达是符号实例，唯一、不可变的。

#### 基本用法
```js
let sym = Symbol();
console.log(typeof sym); // symbol

/* Symbol()可以接收一个参数，用于描述这个symbol*/
let foot = Symbol("foot");
```

#### 使用全局symbol注册表

如果存在，就直接用；如果不存在就创建symbol，然后放到全局注册表中
```js
let foot = Symbol.for("foot");
let otherfoot = Symbol.for("foot");
console.log(foot == otherfoot);  // true
```

#### 使用symbol作为属性
```js
let s1 = Symbol('foot');

let obj = {
	[s1]: '江苏'    // 这个[s1]表达是计算属性名，其实这个属性就是 s1这个symbol
}
console.log(obj[s1]);
```

这个特性正是symbol的主要用途之一
1. 独一无二性， 由于symbol唯一，可以保证属性不会与其他属性冲突，这样可以动态添加内部的或者不希望被遍历发现的属性非常有用
2. 不可枚举性   symbol属性默认不出现在`for...in`循环中，同时也不在`Object.keys()`、`Object.values()`这些方法中
3. 如果需要一个对象的所有symbol属性，需要使用`Object.getOwnPropertySymbols(obj)`方法
```js
let s = Symbol(23);
let obj = {
	name: 'kobe',
	[s]: 24,
};
let sf = Object.getOwnPropertySymbols(obj);  // 获取obj所有的symbol属性
console.log(sf[0]);  
```

#### 内置symbol
> [!todo]
> 此功能好像很强大，可以深入到语言内部，修改掉部分原生的功能，但是目前还没有深入学习，放到以后在学


# 布尔操作符

1. 逻辑非
	1. 用`!`表示，比如`console.log(!false)`等
	2. 如果操作数是对象，则返回false
	3. 如果操作数是空字符串，则返回true
	4. 同样支持`!!` 比如`console.log(!!false)`
2. 逻辑与
	1. 大体上和Java类型，同样有短路逻辑
	2. 但是逻辑与的结果不一定是boolean值
		1. 如果第一个操作数是对象，则返回第二个操作数 （这个操作数可能是一个对象或者是字符串，数字等）
		2. 如果第二个操作数是对象，则只要第一个操作数求值为true才会返回该对象
		3. 如果两个操作数都是对象，则返回第二个操作数
		4. 如果有一个操作数是null，则返回null
		5. 如果有一个操作数是NaN，则返回NaN
		6. 如果有一个操作数是undefined，则返回undefined
3. 逻辑或
	1. 大体上和Java类型，同样有短路逻辑
	2. 但是逻辑与的结果不一定是boolean值
		1. 如果第一个操作数是对象，则返回第一个操作数
		2. 如果第一个操作数求值为false，则返回第二个操作数
		3. 如果两个操作数都是对象，则返回第一个操作数
		4. 如果两个操作数都是null，则返回null
		5. 如果两个操作数都是NaN，则返回NaN
		6. 如果两个操作数都是undefined，则返回undefined

# 运算符

### 特别注意的是  `/`  除法运算符
- 和Java不同的是，JS中除法总是浮点数除法，最后结果可能是一个浮点数，会保留小数部分的
- 如果需要整数，需要搭配Math.trunc()等方法使用
```js
// JavaScript 中获取整数部分
console.log(Math.floor(10 / 3));  // 3
console.log(Math.trunc(10 / 3));  // 3 (推荐)
console.log(~~(10 / 3));          // 3
console.log(parseInt(10 / 3));    // 3
```

### 指数运算符

在ES6之前，计算6的平方，只能使用 `Math.pow(6,2)`， 但是现在可以使用`6 ** 2`这个两个星号的操作符来表达指数运算逻辑

### JS中有 == 和 === 这两种相等操作符

```js
/* == 判断的时候，需要对两个操作符进行强制转换，以表达成一种类型，进行比较*/
let result1 = '55' == 55;  // true
let result2 = '55' === 55;  // false  这个表示是全相等，比较的时候不转换
```

> [!danger]
> 一定要注意到，JS中 == 是一个相对宽松的比较，设计哲学就是尽可能地将不同类型的值进行比较，也就是说JS会进行自动进行类型的转换，然后转换成相同的类型然后再进行比较

