#前端 #JavaScript #集合 #JS 

> 本文主要学习一下对象、数组、Map 、Set等

# Object

两种方式创建Object
```js
let person = new Object();  // 或者简化成let person = {};
person.name = "zmg";
person.age = 30;

/*字面量的方式，属性名可以是字符串或者数值*/
let person = {
  name: "zmg",
  age: 30,
  5: true
}
```

# Array

### 创建的方式

```js
let colors = new Array();
let colors = new Array(5); // 创建大小为5的数组
let colors = new Arrays('blue','red'); // 直接创建了 ['blue','red']数组

/*采用字面量*/
let colors = ['blue','red'];

/*使用静态方法from()*/
let v = Array.from("zmg") ; // ['z','m','g']

const m = new Set().add(1).add(2).add(3);
let m_arr = Array.from(m); // 直接将set转为arr [1, 2, 3]
const a1 = [1,2,3,4]
const a2 = Array.from(a1);  // 相当于copy一个数组，但是是浅拷贝，两个东西不是同一个对象

/*静态方法 of()*/
let v = Array.of(1,2,3,4);  // [1, 2, 3, 4]
```

### 判断数组

- `value instanceof Array`
- `Array.isArray(value)`  现在推荐使用这种

###  迭代器方法

- keys()  
- values()
- entries()

```js
let arr = [1, 3, 5];
console.log(Array.from(arr.keys()));  // [0, 1, 2]
console.log(Array.from(arr.values()));  // [1, 3, 5]
console.log(Array.from(arr.entries())); //[ [ 0, 1 ], [ 1, 3 ], [ 2, 5 ] ]

for (const [idx, v] of arr.entries()) {
  console.log(idx);
  console.log(v);
}
```

### 复制和填充

### fill()
一般我们创建一个数组，可以给她全部填充一些默认值

```js
let arr = new Array(5);
//  全部重置为5
arr.fill(5);
console.log(arr);
// 用1 填充 索引 >= 2的元素
arr.fill(1, 2);
console.log(arr);
// 用8填充 索引 >= 2 且 < 4的元素
arr.fill(8, 2, 4);
console.log(arr);
```

### copyWithin()

```js
let ints = [],
  reset = () => (ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
reset();
// 将ints中的从0开始的内容，插入到索引5开始的位置，直到达到数组边界
ints.copyWithin(5);
console.log(ints); // [0, 1, 2, 3, 4,0, 1, 2, 3, 4]
reset();
```

### 转换方法

- toString()
- valueOf()方法
- join()方法  `arr.join(',')` 用逗号拼接

### 可以把数组当作栈来使用
- pop()
- push()

### 排序方法

- reverse() 这个只是将数组方向排列而已，并不是倒序
- sort()  是升序排列

> [!danger]
> 需要注意的是sort()内部调用的时候会调用String()函数进行转换，最终变成字符串进行比较排序
> 为了解决数字的排序，需要在调用sort()方法的时候接收一个比较函数
> `arr.sort((a, b) => a - b)`

### 操作方法

### concat()

就是拼接数组的逻辑
```js
let arr = ['blue', 'orage'];
let newArr = arr.concat(['red', 'black'], 'skyblue');  // 其中会打散
console.log(newArr);

/*以上的打散逻辑，可以重写，强制其不进行打平*/
let arr = ['blue', 'orage'];
let more = ['red', 'black'];
more[Symbol.isConcatSpreadable] = false;
let newArr = arr.concat(more, 'skyblue');
console.log(newArr);  //  [ 'blue', 'orage', ['red', 'black'], 'skyblue' ]
```

### slice()
跟字符串截取的逻辑类似

### splice()
这个方法比较强大，主要的目的是在数组中间插入元素、删除元素、替换元素
- ==删除==： 传入两个参数，第一个是要开始删除的位置，第二个参数是删除的元素个数
- ==插入==： 传入三个参数，第一个表示开始插入的位置，第二个表示要删除的元素个数，第三个表示是要插入的元素（可以是多个）
- ==替换==：  其实就是跟`插入`一样，只是第二个参数表示的删除的个数 =  要插入的元素的个数就行了

```js
let colors = [],
  reset = () => (colors = ['red', 'blue', 'green']);
reset();
let removed = colors.splice(0, 1);

console.log(colors);  // [ 'blue', 'green' ]
console.log(removed); // [ 'red' ]

reset();
removed = colors.splice(1, 0, 'yellow', 'orage'); 
console.log(colors); // [ 'red', 'yellow', 'orage', 'blue', 'green' ]
console.log(removed); // [] 空数组，因为第二个参数为0，没有删除元素
reset();
removed = colors.splice(1, 2, 'yellow', 'orage');
console.log(colors); // [ 'red', 'yellow', 'orage' ]
console.log(removed);  // [ 'blue', 'green' ]
```

###  搜索和位置方法

- indexOf()
- lastIndexOf()
- includes()

### 迭代方法

这个有点类似Java中的stream api的方式或者是Groovy的closure的逻辑

```js
let colors = ['blue', 'green', 'orange', 'yellow'];

let everyResult = colors.every((item, index, arr) => item.length > 2);  // 判断每个元素的长度都大于2
console.log(everyResult);
let anyResult = colors.some((item, index, arr) => item.length > 4); // 是不是有部分元素的长度大于4
console.log(anyResult);

let filterResult = colors.filter((item, index, arr) => item.length > 4);
console.log(filterResult); [ 'green', 'orange', 'yellow' ]

/* forEach 就类似 for-of循环*/
colors.forEach((item, index, arr) => {
  console.log(item);
});

/*可以转换成新的数组*/
let mapResult = colors.map((item, index, arr) => item.repeat(2));
console.log(mapResult); // [ 'blueblue', 'greengreen', 'orangeorange', 'yellowyellow' ]
```

### 归并方法

比如要计算数组中的所有元素之和

```js
let arr = [1, 2, 3, 5, 6];
let sum = arr.reduce((prev, cur, index, array) => prev + cur);
console.log(sum);
```

# Map

在ES6之前map的形式都是通过Object来实现的，现在有了专门的K-V map

## 使用方式

`const m = new Map()`
或者使用嵌套数组的方式初始化
```js
let map = new Map([
  ['name', 'zmg'],
  ['age', 23],
]);
let map = new Map([[]]); // 创建一个空的

map.set('gender','女');  // 设置属性
map.delete('age'); // 删除属性
map.has('age'); // 判断是否有age这个key
map.get('name') // 获取name的值
console.log(map.size);// 获取map的大小
```

## 遍历的方式

```js
let map = new Map([
  ['name', 'zmg'],
  ['age', 23],
]);
console.log(map.entries === map[Symbol.iterator]); // true
for (const pair of map.entries()) {
  console.log(`key : ${pair[0]} - value = ${pair[1]}`);
}
for (const pair of map[Symbol.iterator]()) {
  console.log(`key : ${pair[0]} - value = ${pair[1]}`);
}
// 可以转为数组
console.log([...map]);
for (const [key, value] of map) {
  console.log(`key : ${key} - value = ${value}`);
}
map.forEach((key, value) => {
  console.log(`key : ${key} - value = ${value}`);
});
for (const [key, value] of map.entries()) {
  console.log(`key : ${key} - value = ${value}`);
}
```

# WeakMap

weakMap和map几乎一样，但是有一个重要的区别
WeakMap的key只能是对象，非对象的key直接报错
因为WeakMap中的key随时可能被销毁，所以不能迭代key

# Set
和Java中的没啥区别，

```js
const s = new Set();
const s = new Set([1,2,3,4,5]);
console.log(s.has(1));
console.log(s.size);
s.add(34).add(23);
console.log(s.size);
s.clear();  // 清除

```