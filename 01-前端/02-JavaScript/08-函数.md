#前端  #JavaScript #JS 

# 1. 箭头函数

```js
// 传统方式
let say = function() {}

// 箭头函数
let say = () => {}
```

箭头函数语法简洁，但是并不是所有场合都适用。箭头函数不能使用`arguments`、`super`、`new.target`，也不能用作构造函数，同时箭头函数没有prototype属性。

## 1.0 this是啥？

另外一个特殊的对象是this，它在标准函数和箭头函数中有不同的行为。

在标准函数中，this引用的是把标准函数当成方法调用的上下文对象。 在全局上下文中，调用函数时，this就是window

这个this到底引用哪个对象必须是函数调用时才能确定。

```js
window.color = 'red';
let o = {
	color: 'blue'
};
function sayColor() {
	console.log(this.color);
}
sayColor(); // 'red'   这个时候调用的时候，上下文是window

o.sayColor = sayColor;   // 将这个方法放入到对象中
o.sayColor(); // 'blue'   // 那么这个方法中的this就是实例对象
```

而箭头函数中，this引用的就是<span class="red-text">定义函数的上下文</span>。  注意： 是定义函数时那个时候的上下文。
```js
window.color = 'red';
let o = {
	color: 'blue'
};
let sayColor = () => console.log(this.color);

sayColor(); // 'red'  // 因为这个箭头函数是在window上下文中定义的，所以不管怎样，这个this就是window
o.sayColor = sayColor;
o.sayColor(); // 'red'
```

有时候我们在处理事件回调或者定时回调某个函数的时候，this值指向的并非我们想要的对象。
此时将回调函数写成箭头函数就可以解决。这是因为箭头函数中的this会保留定义该函数时的上下文。


## 1.1 理解参数

JS函数的参数和Java不一样，你调用的时候，可以传任意个数的参数，他都是可以的
```js
function sayHi() {
    // 通过arguments也是可以的
	console.log("Hello " + arguments[0] + ", " + arguments[1]);
}
// 虽然箭头函数没有arguments参数，但是包含函数后，可以传给她
function foo() {
	let bar = () => {
		console.log(arguments[0]); // 5
	};
	bar();
}
foo(5);
```

## 1.2 默认参数

ES6之后支持默认参数，当参数传`undefined`相当于没有传值
```js
function find(name = 'ZMG') {
  console.log(`hello - ${name}`);
}

function meet(name = 'ZMG', age = 23) {
  console.log(`name = ${name}, age = ${age} `);
}

find();
find('world');
find(null);  // hello - null
find(undefined); // hello - ZMG

meet();
meet(undefined, 30);
```

a. 需要注意的是，参数可以是求值参数
```js
// 讲究顺序合理
function find(name = 'ZMG', fullName = name) {}

// 调用的时候，第二个参数一定要传，要不然会报错

/* 下面的定义是错误，因为fullName赋值的时候name不存在*/
function find(fullName = name,name = 'zmg') {}
```

## 1.3 扩展参数

```js
let arr = [12,4,345];

function getSum() {
	let sum = 0;
	for (let i = 0; i < arguments.length; i++) {
		sum += arguments[i];
	}
	return sum;
}

/*如果不采用扩展操作，就需要将arr展开*/
getSum.apply(null, arr);

/*通过扩展操作*/
getSum(...arr);
```

## 1.4 收集参数

在函数定义的时候可以通过扩展操作把不同长度的参数组合成一个数组

```js
function find(...values) {
  console.log(values);
  console.log(typeof values);
  console.log(values instanceof Array);  // true
}

find('sdf', 'zz');  // 最终封装参数为数组 [ 'sdf', 'zz' ]
find([23, 343]);  // 最终封装参数为  [ [ 23, 343 ] ]

// 收集参数一定是参数中最后一个，这个和Java和groovy一样
function find(...values, last) {}  // 这个是错误
function find(last,...values ) {} // 在最后一个才正确，而且只能有一个

```

## 1.5 new.target逻辑

有时候构造函数也可以被直接函数调用，不是new实例的逻辑，但这种不是我们想的，有没有一种办法可以让他必须new呢，那么就用`new.target`属性，检测函数是否使用new关键字调用

```js
function King() {
	if (!new.target) {
		throw 'King must be instantiated using "new"'
	}
	console.log('King instantiated using "new"');
}
new King(); // King instantiated using "new"
King(); // Error: King must be instantiated using "new"
```


# 2. 函数的属性和方法

- length 属性  ---- 获取函数参数的个数
- prototype属性  

函数有两个重要的方法： `apply()`和`call()`
这两个方法都会以指定的值来调用函数，即会设置调用函数时函数体内的this对象的值。

### a. apply()
apply() 接收两个参数，第一个是函数内的this的值和一个参数数组； 第二个是Array的实例或者arguments对象

```js
function sum(a, b) {
  return a + b;
}

function callSum(a, b) {
  // return sum.apply(this, arguments);   // 传入arguments
  return sum.apply(this, [a, b]);  // 传入数组
}

console.log(callSum(20, 20)); // 40
```

### b. call()

call()方法和apply()方法一样，只是第二个参数一定要传各个参数才行

```js
function sum(num1, num2) {
	return num1 + num2;
}
function callSum(num1, num2) {
	return sum.call(this, num1, num2);  // 逐个传参
}
```

### c. bind()

bind()方法会创建一个新的函数实例，其this值就会绑定到传给bind()的对象。

```js
window.color = 'red';
var obj = {
	color: 'blue',
};
function sayColor() {
	console.log(this.color);
}

sayColor();  // red，此时this就是上下文window
let objSayColor = sayColor.bind(obj);
obj();       // blue  上面就将obj绑定到这个新方法上了
```

# 3. 递归

```js
function fac(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * fac(num - 1);
  }
}

let newFac = fac;
fac = null;  // 将fac重置
console.log(newFac(5));  // 会报错
```

可以使用`arguments.callee`来解决，确保无论通过什么变量调用这个删除都不会出现问题，
```js
function fac(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * arguments.callee(num - 1);  // 这样写就解决了问题
  }
}

let newFac = fac;
fac = null;
console.log(newFac(5));
```

<span class = "red-text">需要注意的是，在严格模式下，arguments.callee无效，会报错</span>
可以采用命名函数表达式来解决
```js
let fac = function f(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * f(num - 1);
  }
};

let newFac = fac;
fac = null;
console.log(newFac(5));

```

# 4. 闭包

很多人把匿名函数就叫闭包，其实不准确。
简单来说，**闭包允许一个函数记住并访问它被创建时说出的词法作用域**

##  4.1 什么是闭包？
 理解闭包需要明白两个概念
 1. **词法作用域**： avaScript 中的作用域是静态的，由代码编写时的位置决定。当函数被定义时，它就确定了自己可以访问哪些变量。它能访问自己的局部变量、父级函数（或块）的变量，以及全局变量。
 2. **函数作为一等公民**： 在 JavaScript 中，函数可以像普通值一样被对待：它可以作为参数传递给另一个函数，可以作为返回值从一个函数中返回，也可以赋值给变量。

用人话解释就是：一个函数 "记住" 了它创建时的环境，即使它离开了那个环境，它仍然能够访问那个环境中的变量。这些被记住的变量，即使外部函数已经执行完毕，其作用域理论上应该被销毁，但它们因为被闭包引用而得以存活。

## 4.2 闭包是如何形成的？

闭包不是你“创建”出来的，而是一种自然现象，只要满足以下条件就会形成：

1. 函数嵌套： 一个函数定义在另一个函数内部。
2. 内部函数引用了外部函数的变量： 内部函数使用了外部函数作用域中的变量（而不是全局变量或其自身的局部变量）。
3. 内部函数被“暴露”出去： 内部函数作为返回值被返回，或者被赋值给一个外部可访问的变量，从而能够在外部作用域中被调用。

```js
function outerFunction(outerVariable) { // 外部函数
  let innerVariable = 'I am inner'; // 外部函数的局部变量

  function innerFunction(innerParam) { // 内部函数
    // innerFunction 引用了 outerFunction 的 outerVariable 和 innerVariable
    console.log(`Outer variable: ${outerVariable}`);
    console.log(`Inner variable: ${innerVariable}`);
    console.log(`Inner param: ${innerParam}`);
  }

  return innerFunction; // 内部函数被返回
}

const myClosure = outerFunction('Hello World'); // outerFunction 执行完毕，但 innerFunction 被返回

// outerFunction 已经执行完毕，其作用域理论上应该被销毁
// 但 myClosure (即 innerFunction) 依然可以访问 outerVariable 和 innerVariable
myClosure('👋');
// 输出：
// Outer variable: Hello World
// Inner variable: I am inner
// Inner param: 👋

// 实现私有逻辑
function createCounter() {
  let count = 0; // 私有变量，外界无法直接访问

  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter(); // 每次调用 createCounter 都会创建独立的闭包
console.log(counter.getCount());    // 0
counter.increment();
counter.increment();
console.log(counter.getCount());    // 2
counter.decrement();
console.log(counter.getCount());    // 1

// 无法直接访问 count
// console.log(counter.count); // undefined

// 创建一个生成乘法函数的工厂
function makeMultiplier(multiplier) {
  return function(number) {
    return number * multiplier;
  };
}

const multiplyByTwo = makeMultiplier(2); // multiplier 闭包中是 2
const multiplyByTen = makeMultiplier(10); // multiplier 闭包中是 10

console.log(multiplyByTwo(5));  // 10
console.log(multiplyByTen(5));  // 50
```

## 4.3 闭包的注意事项
- ==内存消耗==： 由于闭包会保留对外部作用域变量的引用，这些变量在外部函数执行完毕后不会立即被垃圾回收。如果闭包长期存活且引用了大量或大型对象，可能会导致内存泄漏或不必要的内存消耗。在使用闭包时，要注意及时释放不再需要的引用。

- ==this 指向问题==： 闭包并不会自动绑定 this。this 的值取决于函数的调用方式，而不是其定义时的词法作用域。在闭包中使用 this 时，需要特别小心，可能需要使用箭头函数（箭头函数没有自己的 this，会捕获其父作用域的 this）或 bind()、call()、apply() 来明确 this 的指向。

# 5. IIFE 立即执行函数

由于script标签的引用是会暴露全局作用域，所以开发者们想到了一个『立即执行函数』IIFE来模拟私有作用域，避免命名冲突

```js
// 一个模拟模块的 IIFE
;(function() {
  var privateVar = '私有变量';
  
  window.myModule = {
    publicMethod: function() {
      console.log(privateVar);
    }
  };
})();
```

> [!tips]
> 上面的第一行的`;`是为了防止代码和其他代码压缩合并的时候，防御性的处理，万一合并的前一个代码没有用分号结尾，这样贸然的拼接起来，会导致问题
> 第二个问题： 就是为啥`privateVar`在调用后不会销毁？ 那就是因为闭包的原因，因为你返回出去的是一个函数对象，这个就是闭包，由于他引用了变量`privateVar`，所以不会销毁

这个是在模块化出现之前，常用的模拟模块化的方式。


# 6. 高阶函数

什么是高阶函数？

满足以下任意一点都算高阶函数
- 函数的参数接收的是一个函数
- 函数的返回值是一个函数

常用的高阶函数有： Promise、setTimeout()、arr.map等




