#前端 #JavaScript #JS 

> 理解对象、类、继承等


# 1. 理解对象

## 1.1 属性的类型

### 1.1.1 数据属性

- `[[Configurable]]`  表示属性是否可以通过delete删除重新定义，是否可以修改它的特性
- `[[Enumerable]]`  表示属性是否可以通过`for-in`循环返回
- `[[Writable]]`  表示属性的值是否可以被修改
- `[[Value]]`  包含属性实际的值

```js
let persion = {};

Object.defineProperty(persion, 'name', {
  writable: false,
  value: 'zmg',
});

console.log(persion.name);
persion.name = 'kobe';  // 由于属性设置为不可修改，所以他修改无效
console.log(persion.name);
```

## 1.2 合并对象

将一个对象中的属性合并到另外一个对象中
```js
let dest, src, result;
dest = {};
src = { id: 'src' };

result = Object.assign(dest, src);
console.log(result == dest); // true  修改目标对象，同时返回目标对象，所以他们相等
console.log(dest);
```

## 1.3  增强的对象语法

### 1.3.1 属性值简写

```js
let name = 'zmg';
let person = {
  name,   // 这个类似  name : name
};
console.log(person);
```

### 1.3.2  可计算属性

```js
let nameKey = 'name';
let ageKey = 'age';

function getKey(key) {
  return `${key}_0`;
}

let person = {
  [getKey(nameKey)]: 'zmg',
  [getKey(ageKey)]: 34,
};

console.log(person);  // { name_0: 'zmg', age_0: 34 }
```

### 1.3.3  简写方法名

原来的方式：
```js
let p = {
	sayName : function(name) {
	}
}
```
现在的方式；
```js
let p = {
	sayName(name) {}
}
```

## 1.4 对象解构

就是将对象中的属性一次性赋值给多个变量
```js
let p = {
  name: 'kobe',
  age: 23,
};

let { name: pName, age: pAge } = p;
console.log(pName);  
console.log(pAge);

/*如果不想换名字*/
let { name, age } = p;
console.log(name);  
console.log(age);
/*解构复制的时候，不一定每个属性都写，可以按需，如果写一个不存在的属性，最终属性的值是undefined*/
let { name, location } = p;
console.log(location); // undefined
/*在解构中可以直接赋值*/
let { name, location='上海' } = p;
console.log(location); // 上海
```

需要注意的是，只要能够被当作对象的，都能解构， ==null和undefined不能解构==
```js
let { length } = 'ff';
console.log(length); // 得到的就是字符串的长度
let { constructor: c } = 4;  // 从数字中解构一个名为`constructor`的属性，然后赋值给新变量c, 最终指向的是构造函数
console.log(c === Number); // true
```

### 1.4.1 嵌套解构

```js
let person = {
  name: 'zmg',
  age: 20,
  job: {
    title: 'SRE',
  },
};

let personCopy = {};

({ name: personCopy.name, age: personCopy.age, job: personCopy.job } = person);

console.log(personCopy); // { name: 'zmg', age: 20, job: { title: 'SRE' } }
```

由于对象中包含对象引用，所以如果修改person的job中title属性，会影响到personCopy中的属性
```js
let person = {
	name: 'Matt',
	age: 27,
	job: {
	title: 'Software engineer'
}
};
// 声明 title变量并将 person.job.title 的值赋给它
let { job: { title } } = person;
console.log(title); // Software engineer
```

# 2. 创建对象

### 2.1 工厂方法

```js
function createPerson(name, age) {
	let obj = {};
	obj.name = name;
	obj.age = age;
	obj.say = function() {console.log(this.name)};
	return obj;
}
let person = createPerson('zmg',25);
```

### 2.2 构造函数模式

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.say = function () {
    console.log(this.name);
  };
}

let person = new Person('zmg', 29);
console.log(person);
person.say();
```

构造器的方式创建对象没有显式的创建对象，同时构造函数没有return语句
大致的流程：
1. 在内存中创建一个新对象
2. 这个新对象内部的`[[Prototype]]` 特性被复制为构造函数的prototype属性
3. 构造函数内部的this被赋值为这个新对象。相当于this指向了新对象
4. 执行构造器内部的代码

>[!tips]
>构造函数不一定要写成函数声明的方式。赋值给变量的函数表达式也可以表示构造函数
```js
let Person = function(name, age) {
  this.name = name;
  this.age = age;
  this.say = function () {
    console.log(this.name);
  };
};
```

构造函数会带来一个问题，JS中规定函数也是对象，所以每次new一个新的对象出来后，对应的对象内部的函数也会重新创建一份，这样有点多余，为了解决这个问题，可以把函数的定义转移到构造函数外部
```js
let Person = function (name, age) {
  this.name = name;
  this.age = age;
  this.say = say;   // 指向到外部的函数
};
function say() {
  console.log(this.name);
}

let person = new Person('zmg', 29);
console.log(person);
person.say();
```

<span class="red-text">但是这个也有很大的问题，在外面很松散，会引入更多的混乱，所以可以用原型模式来解决</span>

### 2.3 原型模式

在JavaScript中，每个对象都有一个独特的内部属性，指向另一个对象。这个被指向的另一个对象就是他的原型。

原型解决了两个核心问题
1. **继承**：允许一个对象继承另外一个对象的属性和方法，避免代码重复
2. **共享**：多个对象可以共享一份通用的属性和方法，节省内存
**通俗地说，JavaScript 中的原型就是对象的“父母”或“共同模板”。当一个对象自己没有某个属性或方法时，它就会向上去它的原型那里寻找。这条寻找的路径就是原型链。这种机制让 JavaScript 实现了继承和属性共享，是其面向对象特性的基石。**

![[Pasted image 20250723084326.png]]

每个函数都会创建一个`prototype`属性，这个属性是一个对象，包含实例的共享的属性和函数。实际上，这个对象就是通过调用构造函数创建的对象的原型。
```js
/* Person构造函数*/
function Person() {} // let Person = function() {}   是同样的
Person.prototype.name = 'zmg';
Person.prototype.age = 23;
Person.prototype.say = function() {
	console.log(this.name);
}
let p1 = new Person();
p1.say();
let p2 = new Person();
p2.say();
console.log(p1.say == p2.say);  // true
```


> [!tips]
> `__proto__` 和 `prototype`的区别
> - `__proto__`
> 	- 这个是每个对象实例都有的内部属性，它指向他的原型，现在不推荐使用了
> 	- 可以通过`Object.getPrototypeOf(person)`  来获取`person`的原型
> - `prototype`
> 	- 这个是**函数**特有的属性，他指向一个对象，这个对象就是通过这个函数创建的所有实例的共同原型
> 	- 让你使用`new`调用一个构造函数的时候，新创建的对象`__proto__`就会指向这个构造函数的`prototype`属性

```js
function Person() {}
Person.prototype.name = 'zmg';
Person.prototype.age = 23;

let p = new Person();
console.log(p.hasOwnProperty('name')); // false  因为没有这个属性，这个属性是在原型上的
console.log('name' in p);   // true
p.name = 'kobe';
console.log(p.hasOwnProperty('name'));  // true  
console.log('name' in p);   // true


/*判断某个属性是否存在于原型上*/
function hasPrototypeProperty(object, name) {
	return !object.hasOwnProperty(name) && (name in object);
}
```

还有其他的原型方式
```js
let Person = function () {};

Person.prototype = {
  name: 'zmg',
  age: 23,
  say() {
    console.log(this.name);
  },
};

let p = new Person();
p.say(); 

console.log(p.constructor == Person); // false
console.log(p.constructor == Object); // true
```

以上的方式创建prototype会导致一个问题，Person.prototype的constructor属性 不指向Person了。
解决这个方法，就是特意包含constructor属性，并设置为Person
```js
let Person = function () {};

Person.prototype = {
  constructor: Person,  // 此处直接指向Person即可
  name: 'zmg',
  age: 23,
  say() {
    console.log(this.name);
  },
};

let p = new Person();
p.say();
console.log(p.constructor == Person);

```

> [!danger]
> 原型最大的问题就是共享，如果属性共享的话，可能会出现问题，a修改了属性可能会影响b

# 3. 继承

## 3.1 原型链

**当访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 引擎就会沿着它的原型链向上查找，直到找到该属性/方法或者到达原型链的顶端（null）为止。**
这种沿着原型链查询的机制就叫『委托』。

```js
let Super = function () {
  this.name = 'zmg';
};

Super.prototype.getSuperValue = function () {
  return this.name;
};

let Sub = function () {
  this.subName = 'kobe';
};

// 继承 -- 这个是最关键的
Sub.prototype = new Super();

Sub.prototype.getSubValue = function () {
  return this.subName;
};

let s = new Sub();
console.log(s.getSuperValue());  // zmg
```

### 3.1.1 原型链的问题

1. 需要注意的是：以字面量方式创建原型方法会破坏之前的原型链

```js
//**** 以上的代码
// 继承
Sub.prototype = new Super();

/* 以下通过字面量的方式创建原型方法的话，导致上面Sub.prototype= new Super()失效，这样Sub 和Super没有任何关系了*/
Sub.prototype = {
  getSubValue() {
    return this.subName;
  },
};

let s = new Sub();
console.log(s.getSuperValue());
```

2. 原型中的引用对象会共享

```js
let Super = function () {
  this.colors = ['blue', 'orange'];
};

let Sub = function () {};

// 继承
Sub.prototype = new Super();

let s = new Sub();
s.colors.push('black');
console.log(s.colors);   // [ 'blue', 'orange', 'black' ]
let s2 = new Sub();
console.log(s2.colors);  // [ 'blue', 'orange', 'black' ]
```

**导致由于colors属性是继承出来的，最终在Sub.prototype中有一个colors属性，这个属性会在不同实例间共享**

### 3.1.2 盗用构造器

为了解决上面说的父类的属性被继承导致子类的所有实例共享相同的属性，可以采用`盗用构造器`的方式

```js
let Super = function () {
  this.colors = ['blue', 'orange'];
};

let Sub = function () {
  // 继承Super，这样Super的属性就不会被子类的所有的实例共享了
  Super.call(this);
};
```

### 3.1.3 组合继承

盗用构造器的逻辑只能继承父类构造器的属性和方法，但是原型属性和方法没有继承，所以需要将之前使用的方式联合盗用，组成组合继承，这样就几乎完美解决问题

```js
let Super = function () {
  this.colors = ['blue', 'orange'];
};

let Sub = function () {
   // 盗用
  Super.call(this);  // 第二次调用Super构造器
};

// 继承方法
Sub.prototype = new Super();   // 第一次调用Super构造器

let s = new Sub();
s.colors.push('black');
console.log(s.colors);
let s2 = new Sub();
console.log(s2.colors);
```

### 3.1.4 原型继承

我们发现每次使用Super子类的时候都需要显式的创建一个Sub类，那么有没有办法定义Sub，但是又有子类的效果呢？
```js
function object(o) {
	function F() {}; // 内部整一个构造函数
	F.prototype = o;
	return new F();
}

/* 以下是使用 */
let Super = function () {
  this.colors = ['blue', 'orange'];
};

let sub = object(new Super());
sub.name = 'zmg';
console.log(sub.colors);
```

在ES5版本中新增了`Object.create()`方法规范化上面的那个object方法

```js
let Super = function () {
  this.colors = ['blue', 'orange'];
};

let sub = Object.create(new Super());
sub.name = 'zmg';
console.log(sub.colors);
```

### 3.1.5 寄生式继承

```js
function createAnother(original){
	let clone = object(original); // 通过调用函数创建一个新对象
	clone.sayHi = function() { // 以某种方式增强这个对象
		console.log("hi");
	};
	return clone; // 返回这个对象
}

/*以下使用*/
let person = {
	name: "Nicholas",
	friends: ["Shelby", "Court", "Van"]
};
let anotherPerson = createAnother(person);
anotherPerson.sayHi(); // "hi"
```

### 3.1.6 寄生式组合继承

在上面将的组合继承中，会发现Super构造函数被调用了两次，性能上会比较差，所以最佳的继承解决方案就是**寄生式组合继承**

```js
// 父类构造函数
function Super(name) {
  this.name = name; // 实例属性
  this.colors = ['red', 'blue']; // 引用类型的实例属性
  console.log('Super constructor called for:', this.name || 'Anonymous');
}

// 父类原型方法
Super.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}.`);
};

// 寄生组合式继承实现
function inheritPrototype(subType, superType) {
  // 1. 创建父类原型的一个副本 (寄生部分)
  // 避免直接 new superType()，因为它会执行 superType 构造函数
  let prototype = Object.create(superType.prototype);
  // 2. 修复 constructor 指向 (组合部分)
  prototype.constructor = subType;
  // 3. 将这个新对象赋值给子类的原型
  subType.prototype = prototype;
}

// 子类构造函数
function Sub(name, age) {
  // 1. 借用构造函数，继承父类的实例属性
  // 确保每个 Sub 实例都有自己的 name 和 colors 副本
  Super.call(this, name);
  this.age = age; // 子类自己的实例属性
}

// 2. 实现原型继承：将 Sub 的原型指向 Super 原型的一个副本
// 这样 Sub 的实例就能通过原型链访问 Super 的原型方法
inheritPrototype(Sub, Super);

// 子类自己的原型方法
Sub.prototype.sayAge = function() {
  console.log(`I am ${this.age} years old.`);
};
```

其中最核心的代码就是这一部分寄生逻辑

```js
// 寄生组合式继承实现
function inheritPrototype(subType, superType) {
  // 1. 创建父类原型的一个副本 (寄生部分)
  // 避免直接 new superType()，因为它会执行 superType 构造函数
  let prototype = Object.create(superType.prototype);
  // 2. 修复 constructor 指向 (组合部分)
  prototype.constructor = subType;
  // 3. 将这个新对象赋值给子类的原型
  subType.prototype = prototype;
}
```

所以JS中在ES6之前继承的最佳实践就是`寄生式组合继承`

# 4. 类

在ES6引入的`class`和Java中不是一个概念，他只是对`寄生式组合继承`的一个语法糖的包装，因为`寄生式组合继承`代码很冗长和混乱。

## 4.1 类定义

和函数定义相同，也有两种方式
```js
// 类声明
class Person {}

// 类表达式
let Person = class {}

// 类表达式的名称可选
let Person = class Person_1 {}   //这个 Person_1可选
```

> [!tips]
> 需要注意的是：类定义 不能导致 类提升

### 4.1.1 函数的构成

```js
class Foo {
  // 公开属性
  age = 23;
  // 私有属性
  #name = 'zmg';
  // 构造器
  constructor() {}
  // 静态函数
  static myF() {}
  // getter方法
  get myFoo() {}
  // 普通函数
  hasC() {}
}
```

### 4.1.2 实例、原型以及类成员

#### a. 实例成员

每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享

```js
class Person {
  constructor() {
    this.name = new String('zmg');

    this.sayName = () => {
      console.log(this.name);
    };
    this.colors = ['blue', 'red'];
  }
}

let p1 = new Person();
let p2 = new Person();

console.log(p1 == p2);  // false
console.log(p1.name == p2.name); // false
p1.colors.push('black'); 
console.log(p1.colors);  // [ 'blue', 'red', 'black' ]
console.log(p2.colors);  // [ 'blue', 'red' ]
```

#### b.原型方法与访问器

为了不同实例间共享方法，类定义语法把在类块中定义的方法作为原型方法

```js
class Person {
  constructor() {
    this.say = () => {
      console.log('zmg');
    };
  }

  say() {
    console.log('原型的say');
  }
}

let p = new Person();
p.say();   // zmg
Person.prototype.say();  // 原型的say
```

类定义也支持`setter`和`getter`方法，作为访问器
```js
class Person {
  set name(_name) {
    this._name = _name;
  }
  get name() {
    return this._name;
  }
}

let p = new Person();
p.name = 'zmg';  // 其实就自动调用封装的set name这个方法   其实这个name调用的是name方法
console.log(p.name);   // 自动调用封装的get name方法
```

## 4.2 类继承

### 4.2.1 实现继承

```js
class Vehicle {}

// 继承类
class Bus extends Vehicle {}

let b = new Bus();
console.log(b instanceof Vehicle); // true
console.log(b instanceof Bus); // true

// 继承普通的构造函数
function Vehicle() {}
// 继承普通的构造函数
class Bus extends Vehicle {}

let b = new Bus();
console.log(b instanceof Vehicle); // true
console.log(b instanceof Bus); // true
```

### 4.2.2 构造函数、super

子类的方法可以通过`super`关键字来引用他们的原型。**这个关键字只能在子类中使用，而且仅限于类构造函数、实例方法、静态方法内部。**

```js
class Vehicle {
  constructor() {
    this.hasEngine = true;
  }
}

class Bus extends Vehicle {
  constructor() {
    // 不要在调用super()之前引用this，否则会抛出异常
    super();
    this.style = 'blue';
  }
}

let b = new Bus();
```

### 4.2.3 抽象类

严格意义上来说JS没有Java中抽象类的概念，只能通过硬核编码实现『抽象类』的逻辑。
通过`new.target`判断就能够做到
```js
class AbsClass {
  constructor() {
    if (new.target == AbsClass) {
      throw new Error('这是一个抽象类，不能实例化');
    }
    if (!this.say) {
      throw new Error('子类必须实现say()');
    }
  }
  speak() {
    // 模拟抽象方法，强制子类实现
    throw new Error("子类必须实现 'speak' 方法。");
  }
}

let abc = new AbsClass();  // Error: 这是一个抽象类，不能实例化
```