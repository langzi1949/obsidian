#前端 #JavaScript #Math

> 本文讲JavaScript中常见的引用类型

> [!notes]
> 首先，我们来说明一下引用类型和类之间的关系
> - 引用类型是一种`数据类型分类`，表示存储在堆内存中的复杂数据结构，而类是一种语法结构，定义对象的模板
> - 引用类型是`值`，类不是值，仅仅是定义类型的方式
> - 引用类型一般通过：对象字面量{}、数组[]、new Date()、new Map()等方式或者new ClassName()的方式创建实例
> - 引用类型的对象通过==原型链==实现继承， 而类通过`extends`这种语法糖来实现继承
# Date

date的用法和Java的几乎一致，他们就是参考早期的Java的juD的实现。

```js
let now = new Date();
let date1 = new Date('2023-01-04');
console.log(date1);
let isoString3 = '2023-01-15T10:30:00+02:00'; // 带时区偏移
let date3 = new Date(isoString3);
console.log(date3);
let str = '2025-08-09 08:09:23';
let date4 = new Date(Date.parse(str));  // 最后其实是一个默认的是当前时区转为UT+0
console.log(date4);
```

> [!tips]
> 值得注意的是，虽然原生的JS中已经提供了Date类型的结构，但是在实际开发中基本上都依赖第三方的库或者模块
> 常见的比如:
> - `day.js` : 轻量级的日期时间处理库，大小仅有2kb  推荐使用
> - `date-fns`  功能强大且模块化的日期处理库，支持函数式编程，适合复杂日期处理的项目
> - `luxon` 由moment.js 团队开发，更加现代化，支持国际化和时区的处理
> - `moment.js` 老牌的时间库，不推荐使用了

# RegExp

正则表达式，没啥好说的，用到的时候直接参考文档就行

# 原始值包装类型

- Boolean `new Boolean(true)`
- Number  `new Number(23)`
- String   `new String('abg)`

# 重点介绍String的一些用法

```js
let str = 'abc';
let len = str.length;   // length属性获取长度
let newStr = str.concat('zmg'); // abczmg  进行拼接
```

### 字符串获取子字符串的方法

- slice()
- ~~substr()~~
- substring()

1. **slice()**
	1. 接受一个或者两个参数，如果一个的话，代表字符串开始的位置，第二个代表的是字符串结束的位置 <span class = "red-text">(不包含结束位置的那个字符，跟Java一样)</span>
	2. 如果第二个字符串的位置已经超过字符长度的，那就相当于到末尾，包含最后一个字符
	3. 如果第一个和第二个参数为负数的话，都自动转为 <span class = "red-text"> len(字符串) + 这个负数</span>
2. **~~substr()~~**
	1. ~~接受一个或者两个参数，如果一个的话，代表字符串开始的位置，第二个代表的是<span class = "red-text">截取的字符串的长度</span>~~
	2. ~~==由于上面特别坑爹的困惑==，在目前ES6之后已经废除了这个方法，所以就别用了，但是知道这个使用就行~~
	3. ~~第一个负数的参数当成字符串长度加上该值，将第二个负数参数直接转换为0.  所以这个方法中第二个参数如果为负数的话，最终的结果永远都是空字符串~~
3. **substring()**
	1.  接受一个或者两个参数，如果一个的话，代表字符串开始的位置，第二个代表的是字符串结束的位置 <span class = "red-text">(不包含结束位置的那个字符，跟Java一样)</span>
	2. 如果第二个字符串的位置已经超过字符长度的，那就相当于到末尾，包含最后一个字符
	3. 参数为正数的话，逻辑和slice()是一致的
	4. 如果参数为负数的话，会将所有的负数参数直接转为0，如果一样的，如果第二个参数为负数，结果永远为空字符串
	5. 如果第一个参数为正数，第二个参数为负数 怎么办？  ==substring(3, -4)  ->  substring(3, 0) -> substring(0,3)==
	6. 是因为substring的内部处理逻辑，永远将较小的那个参数作为起始位置
	
```js
let str = 'hello world';
console.log(str.slice(3)); //lo world
console.log(str.substr(3)); //lo world
console.log(str.substring(3)); //lo world
console.log(str.slice(3, 7)); //lo w
console.log(str.substr(3, 7)); //lo world
console.log(str.substring(3, 7)); //lo w

console.log(str.slice(-3)); //rld 就相当于11+(-3) = 8  那么就从索引8开始
console.log(str.substr(-3)); //rld
console.log(str.substring(-3)); // hello world
console.log(str.slice(3, -4)); // lo w
console.log(str.substr(3, -4)); // ""
console.log(str.substring(3, -4)); // hel
```

### 字符串位置方法

- indexOf()  --- 从开头找
- lastIndexOf()  -- 从结尾开始找

### 字符串包含方法

- startWith()  --> 判断是否是某个字符串开头
- endWith()  -->  判断是否是某个字符串结尾
- includes()  --> 判断是否包含某个字符串，JS中没有Java中的contains的方法

>[!danger]
>`endWith()`方法支持可选的第二个参数，代表的就是你认为的字符串的末尾位置

### trim方法

删除前后的所有空格，并返回结果，不破坏原有的字符串

### repeat()方法
参数为整数，表示复制原有字符串N次

```js
let str = 'hello world';
console.log(str.repeat(3));  // hello worldhello worldhello world
```

### padStart() 和 padEnd()方法

他们同样会复制字符串，如果小于指定长度，则在响应的一侧填充字符，直到满足长度条件
```js
let str = 'foo';
console.log(str.padStart(7, '.')); // ....foo
console.log(str.padEnd(8, '*')); // foo*****
```

### 字符串迭代和结构

字符串的原型上会暴露@@iterator，表示迭代
```js
let message = 'abg';
let sIterator = message[Symbol.iterator]();  // 获取迭代器
console.log(sIterator.next());  //{ value: 'a', done: false }
console.log(sIterator.next()); //{ value: 'b', done: false }
console.log(sIterator.next());  // { value: 'g', done: false }
console.log(sIterator.next()); //{ value: undefined, done: true }
```

可以使用`for-of`语句
```js
for (const c of message) {
	console.log(c);
}
```

可以解构
通过 展开语法 使用`...`  这样就将可迭代的类型展开了，最后用`[]`包裹就是一个数组Array
```js
let message = "abcd";
console.log([...message]);
```

```js
const originalArray = [1, 2, 3];
const copiedArray = [...originalArray];
console.log(copiedArray); // [1, 2, 3]
console.log(originalArray === copiedArray); // false (是新数组)

/*合并数组*/
const arr1 = [1, 2];
const arr2 = [3, 4];
const combinedArray = [...arr1, ...arr2, 5];
console.log(combinedArray); // [1, 2, 3, 4, 5]

/*将数组的元素作为函数的独立参数传递*/
function greet(name1, name2, name3) {
  console.log(`Hello ${name1}, ${name2}, and ${name3}!`);
}
const names = ['Alice', 'Bob', 'Charlie'];
greet(...names); // 相当于 greet('Alice', 'Bob', 'Charlie')

/*对象属性的复制和合并*/
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const combinedObj = { ...obj1, ...obj2, e: 5 };
console.log(combinedObj); // { a: 1, b: 2, c: 3, d: 4, e: 5 }

const newObj = { ...obj1, b: 99 }; // 覆盖同名属性
console.log(newObj); // { a: 1, b: 99 }
```

# Math

### Math对象属性(数学中的一些特殊值)

- Math.E
- Math.PI
- Math.LN2      2为底的自然对数

### max()和min()方法
```js
let max = Math.max(3, 54, 32, 16);
console.log(max); // 54
let min = Math.min(3, 54, 32, 16);
console.log(min); // 3

/* 如果知道数组中的最大值或者最小值呢？*/
let values = [1, 2, 3, 4, 5, 6, 7, 8];
let max = Math.max(...values);
```

### 四舍五入

- Math.ceil()  始终向上舍入最接近的整数
- Math.floor()  始终向下舍入最接近的整数
- Math.round() 始终执行四舍五入

对于负数的四舍五入同样也是上面的逻辑，但是round就代表离哪一个值更近

### random()方法

Math.random()方法返回一个 0~1 范围内的随机数，其中包含 0 但不包含 1。
```js
/*获取1-10之间的随机数*/
let num = Math.floor(Math.random() * 10 + 1);
```