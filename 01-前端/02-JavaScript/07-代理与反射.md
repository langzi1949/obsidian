#前端  #JavaScript #JS 

# 1. 代理

## 1.1 创建空代理

```js
const target = {
  id: 'target',
};

const handler = {};

const proxy = new Proxy(target, handler);
console.log(target == proxy); // false
// id属性会访问同一个值
console.log(target.id === proxy.id);
proxy.age = 23;
console.log(target.age); //  23
```

上面handler的作用就是要定义各种拦截器来增强target的能力，但是现在handler是空的，相当于proxy的行为和targer是完全一致的，所有对`proxy`的操作都会直接转发给原始的`targe`t对象

## 1.2 定义捕获器

只有在hander中定义捕获器才有意义，这个捕获器其实类似Java中的拦截方法

```js
const target = {
  id: 'target',
};

const handler = {
  // 会拦截proxy[property]、 proxy.property或 Object.create(proxy)[property]等操作
  get() {
    return '拦截器的值';
  },
};

const proxy = new Proxy(target, handler);
console.log(target.id); //target
console.log(proxy.id);  //拦截器的值
```

所有的捕获器(trap)都可以访问相应的参数，基于这些参数可以增强拦截方法的能力。比如，get()拦截器会接收到`目标对象`、`要查询的属性`、`代理对象`三个参数
```js
const target = {
  id: 'target',
};

const handler = {
  get(trapTarget, property, receiver) {
    console.log(trapTarget == target);
    console.log(property);
    console.log(receiver == proxy);
    return trapTarget[property];
  },
};

const proxy = new Proxy(target, handler);
console.log(target.id); //target
console.log(proxy.id); //target

```

所有的拦截器都可以基于自己的参数重建原始操作，但是可能不想get拦截器这么简单，有一种方式是全局Reflect对象上的同名方法来轻松重建
```js
const target = {
  id: 'target',
};

const handler = {
  get() {
    return Reflect.get(...arguments);
    // 上面一行可以简写成
    // get: Reflect.get;
  },
};

const proxy = new Proxy(target, handler);
console.log(target.id); //target
console.log(proxy.id); //target
```

## 1.3 捕获器不变式

使用捕获器几乎可以改变所有基本方法的行为，但是需要规范，不能瞎搞。
比如：目标对象有一个不可配置且不可写的数据属性，如果捕获器返回一个与该属性不同的值时，就报错啦。
```js
const target = {};
Object.defineProperty(target, 'foo', {
  configurable: false,
  writable: false,
  value: 'bar',
});

const handler = {
  get() {
    return 'qux';
  },
};
let proxy = new Proxy(target, handler);

proxy.foo;  // TypeError
```

## 1.4 反射API
handler中定义的捕获器或者拦截器，是固定的，JS引擎预设好的，我们直接用就行。
总共有13种捕获器和反射API
比较常见的就几种：

### a. get()

get()会在获取属性值的时候被调用，对应的反射API: `Reflect.get()`
```js
const myTarget = {};
const proxy = new Proxy(myTarget, {
	// target: 目标对象
	// property : 目标对象上的字符串键属性名称
	// receiver:  代理对象或者继承代理对象的对象
	get(target, property, receiver) {
		console.log('get()');
		return Reflect.get(...arguments)
	}
});
proxy.foo;
```

### b. set()
set()捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 `Reflect.set()`。

```js
const myTarget = {};
const proxy = new Proxy(myTarget, {
	// value: 要赋值给属性的值
	set(target, property, value, receiver) {
		console.log('set()');
		return Reflect.set(...arguments)
	}
});
```

### c. has()
has()捕获器会在 in操作符中被调用。对应的反射 API 方法为 `Reflect.has()`。
拦截以下方法：
- property in proxy 
- property in Object.creat(proxy)
- with(proxy) {(property)}
- reflect.has(proxy, property)

```js
const myTarget = {};
const proxy = new Proxy(myTarget, {
	has(target, property) {
		console.log('has()');
		return Reflect.has(...arguments)
	}
});
```

### d. constructor()
construct()捕获器会在 new操作符中被调用。对应的反射 API 方法为 Reflect.construct()。target 必须可以用作构造函数。

```js
const myTarget = function() {};
const proxy = new Proxy(myTarget, {
	// target: 目标构造函数
	// argumentsList: 传给目标构造函数的参数列表。
	// newTarget: 最初被调用的构造函数。
	construct(target, argumentsList, newTarget) {
		console.log('construct()');
		return Reflect.construct(...arguments)
	}
});
new proxy;
// construct()
```

### e. apply()

这个几乎是最重要的捕获器了了，apply()捕获器会在调用函数时中被调用。对应的反射 API 方法为 Reflect.apply()。

```js
const myTarget = () => {};
const proxy = new Proxy(myTarget, {
	// target: 目标对象(必须是一个函数对象)
	// thisArg: 调用函数时的 this参数。
	// argumentsList:调用函数时的参数列表
	apply(target, thisArg, ...argumentsList) {
		console.log('apply()');
		return Reflect.apply(...arguments)
	}
});
proxy();
// apply()
```

## 1.5 很重要的实践

如果代理执行target的普通方法，应该在handler中如何实现呢？ 你发现只用apply拦截器是有问题的。
需要配合get和apply两个拦截器才能实现

```js
const target = {
  name: 'Target Object',
  say(message) {
    console.log(`${this.name} says: ${message}`);
    return `Target finished: ${message}`;
  },
};

const handler = {
  // 1. 拦截对方法的访问（get trap）
  get(target, property, receiver) {
    const value = Reflect.get(target, property, receiver); // 获取原始属性值

    // 如果获取到的是一个函数，并且不是构造函数
    if (typeof value === 'function' && property !== 'constructor') {
      // 2. 返回一个代理函数
      return new Proxy(value, {
        // 3. 这个代理函数使用 apply trap 来拦截实际的方法调用
        apply(funcTarget, funcThisArg, funcArgumentsList) {
          // 在原始方法执行前添加日志
          console.log('方法执行开始......');

          // 确保 thisArg 正确指向 proxy 实例或 target 实例
          // 如果方法内部有其他对 this 的访问，它们也会经过 outer proxy 的拦截
          const actualThisArg = receiver;

          // 执行原始方法
          const result = Reflect.apply(
            funcTarget,
            actualThisArg,
            funcArgumentsList
          );

          // 在原始方法执行后添加日志
          console.log('方法执行结束......');

          return result; // 返回原始方法的执行结果
        },
      });
    }
    // 对于非函数属性，直接返回
    return value;
  },
};

const proxy = new Proxy(target, handler);

console.log('--- Calling proxied say method ---');
const resultSay = proxy.say('Hello from outside!');
console.log(`Result from say: ${resultSay}`);
console.log('\n--- Accessing a property ---');
console.log(proxy.name); // 仅触发 get trap, 不会触发 apply
```

重点有两个疑问：
1. 为啥不能直接apply呢？
2. 为啥需要在get拦截器中返回一个代理函数？
分析一下步骤:
- **阶段一： 属性访问（proxy.say）**
	- 当JS引擎看到==proxy.say==时，他会调用get拦截器，如果get拦截器没有，那么就返回的是target.say， target.say是一个方法，所以直接调用了target.say()，不会走到apply拦截器里面  因此只有apply拦截器是不行的
	- 现在有get拦截器去拦截proxy.say的逻辑，他认为这是一个属性，需要去拦截
	- **get内部进行了处理，发现他是一个函数，因此就return了一个proxy对象，这个对象称之为『代理函数』**
	- 此刻，proxy.say的表达式求值结果就是这个新的代理函数
- **阶段二： 函数调用 ((...))**
	- 紧接着proxy.say后面是一个括号，意味着JS引擎要调用这个proxy.say的表达式的求值结果
	- **==而这个求值结果就是get拦截器返回的新的代理函数==**
	- 当一个函数被调用时，如果他是代理函数，那么就会被他的apply拦截器拦截
	- 所以最后一步，实际上触发了==**被get拦截器返回的那个代理函数的apply拦截器**==