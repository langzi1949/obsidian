#Go #Golang 
# 1. 函数

> [!tips]
> 在go里面，函数和方法是两个不同的概念
> 1. 函数是在包里面直接定义的
> 2. 方法是依托在struct上的，在struct上的函数，称之为方法

## 1.1 函数声明

```go
func name(params) (result-list) {
	body
}

// 💊 💊 💊这种方式， 强调第二个参数没有用到
func first(x int, _ int) int { return x }  

// 命名返回值，给返回值除了类型，也命名一下，大家容易理解
func Size(rect image.Rectangle) (width, height int) {}
```

- 如果没有返回值的话，就不用写`result-list`，而且只有一个结果的话，`result-list`不用括号包裹
- 如果多个参数相同类型的话，在最后一个参数前指定类型即可，可简写 `(x, y int)`  这种方式
- 上面💊 这个怎么理解？ 为啥有一个参数没有用到，却还要定义呢、
	- 有时候实现接口，接口中方法的约束，但是我确实只用一个参数就行了
	- 在回调函数中可以用到
- 函数作为类型，在go中函数也是一种类型，可以将函数赋值给一个变量，或者将函数作为参数传递给另一个函数--和JavaScript很像
- go函数没有默认参数值的概念，同时没有地方通过参数名指定形参，就老老实实的正常调用即可
- 实参通过值的方式传递，因此函数的形参是实参的拷贝，对形参的修改不会影响实参。但是如果实参是引用类型，如指针、slice、map、function、channel等类型，在函数体内可以间接修改到实参的数据
- 针对上面的上面的命名返回值的方式， 在函数体中return语句就可以直接写`return`就行了
```go
func swap(x, y int) (a, b int) {   // 命名返回值
	a = y
	b = x
	// return 语句可以省略参数，它会自动返回 a 和 b 的值
	return
}
```

- 接收和忽略多返回值，有时候我们只需要一个返回值，可以使用空白符`_`来忽略其他返回值

```go
func getInfo() (string, int) {
	return "Go Lang", 2009
}

func main() {
	// 只需要第一个返回值，忽略第二个
	name, _ := getInfo()
	fmt.Println("语言名称:", name)
}
```

## 1.2 函数错误的处理

go的设计哲学：错误是正常的，而不是异常
- 显式优于隐式
	- try-catch是一种隐式控制流，有时候在很深的调用栈中捕获到异常，不利于排查问题
	- go的error机制，强制你在每个可能出错的地方显式来处理错误
- 区分可恢复的错误和不可恢复的错误
	- go认为『可恢复的错误』是一种正常的、可预料的情况，请使用`error`来处理
	- 不可恢复的错误，go提供了`panic`和`recover`来捕获处理

### 1.2.1 错误处理的策略

1. 将error传播出去

```go
resp, err := http.Get(url)
if err != nil {
	return nil, err   // 直接返回出去，相当于传递出去
}
```

2. 将error包装一下再返回

```go
resp, err := http.Get(url)
if err != nil {
	return nil, fmt.Errorf("http get : %v", err)  // 相当于包装了error再返回
}
```

在调用链上，通过`fmt.Errorf()`函数最终通过`fmt.Sprintf()`函数格式化错误，这些错误会通过链式组合在一起，所以在错误信息中避免使用大写和换行符，这样输出日志后，可以快速检索出来

3. 重试机制
在调用时候，如果发生错误了，可以进行多次重试，这个之前在Java上有过实践，就是for循环+sleep +limit 限制次数，不能无限尝试

4. 输出错误信息并结束程序 ---- 注意，这个一般只应该在main函数中执行

```go
// (In function main.)
if err := WaitForServer(url); err != nil {
	fmt.Fprintf(os.Stderr,"Site is down: %v\n", err)
	os.Exit(1)
}
```

以上的代码可以用，他们是等价的，`log.Fatalf` 这个输出信息后，就会退出程序
```go
if err := WaitForServer(url); err != nil {
log.Fatalf("Site is down: %v\n", err)
}
```

5. 直接记录错误到日志即可，不传递也不处理
```go
if err := Ping(); err != nil {
	log.Printf("ping failed: %v; networking disabled",err)
}
```

6. 最后一种策略，直接忽略处理，不处理，也不记录


## 1.3 函数值

函数可以 拥有类型，也可以被赋值给其他变量

函数的类型的零值是`nil`，调用值为`nil`的函数会引起panic错误

函数值可以与`nil`比较

函数值之间不可以比较，也不能用函数值作为map的key

## 1.4 匿名函数

匿名函数的定义很简单，跟具名函数类似，除了没有名字

```go
v := func(i int) int { return i + 1 }  // 这就是一个匿名函数
```

有时候匿名函数类似JavaScript的闭包的概念

```go
func squares() func() int {
	var x int

	return func() int {
		x++
		return x * x
	}
}

func testClosure() {
	f := squares()

	fmt.Println(f())  // 1
	fmt.Println(f())  // 4
	fmt.Println(f())  // 9
}
```

分析上面的代码
-  首先`squares()`函数返回一个匿名函数
- 这个匿名函数劫持了变量x，这个变量不会被垃圾回收，同时这个x在同一个匿名函数实体间是共享的
- `f()` x变成了1，后面再调用的时候，x的值不会重置为0 ，而是之前变化的值，因为匿名函数实体之间x的值是共享的


在Go 1.21版本之前有个很大的坑，就是for循环中的迭代变量共享的问题，这个会导致闭包的一个重大问题
```go
// 以前的代码（有 Bug）
var funcs []func()
for i := 0; i < 3; i++ {
    funcs = append(funcs, func() {
        fmt.Println(i)
    })
}
// 当你执行这些函数时，它们都打印的是 3，而不是 0, 1, 2
```

这种反人类的设计，太逆天了，好在Go1.22版本后，这个问题已经优化了，==**每次for循环的迭代都会独立创建一个变量副本**==，这样就不会有问题了
如果别人问起，那么在1.21版本之前，如何修复这个问题呢？
1. 在循环体内用一个局部变量接收一下
2. 使用函数参数传递，相当于匿名函数再包一个匿名函数自调用。。。。

## 1.5 可变参数

可变参数只能在最后一个参数上使用

```go 
func sum(a int, vals... int) {}
```

对于可变参数，可以不传值，也可以传多个值

## 1.6 defer 函数

这个函数很有用，类似Java中在finally中处理文件的关闭，资源的关闭，连接的关闭，释放锁等操作

defer 修饰的语句，会在return前执行，它不会阻塞这个语句后面的逻辑，会在包含这个defer的函数体return、painic异常结束 前会执行

```go
func readFile(filename string) {
	f, err := os.Open(filename)
	if err != nil {
		fmt.Println("无法打开文件:", err)
		return
	}
	// 在函数返回时关闭文件
	defer f.Close() 

	// 这里进行文件读取操作...
	fmt.Println("文件已打开，正在处理...")
}
```

- 栈机制 ，如果多个defer语句的话，按照栈的逻辑进行处理，后进先出的原则

```go
func main() {
    defer fmt.Println("第一个 defer")
    defer fmt.Println("第二个 defer")
    fmt.Println("中间语句")
}
// 输出:
// 中间语句
// 第二个 defer
// 第一个 defer
```

- 参数在声明时求值，`defer`语句的参数会在`defer`语句被声明的时立即求值，而不是在执行时求值

```go
func main() {
    i := 0
    defer fmt.Println(i) // 这里 i 的值立即被求值为 0
    i++
    fmt.Println("i 的值是:", i) // 输出: i 的值是: 1
}
// 最终输出: 
// i 的值是: 1
// 0
```

## 1.7 panic异常

这个就是运行时的出现的异常，当然也可以手动直接调用内置的`panic`函数，也会引发panic异常
在健壮的程序中，任何可以预料到的错误，最好的处理方式是用Error机制，而不是Panic机制

## 1.8 recover

这个其实就是让panic不崩溃导致程序停止，相当于恢复

recover必须要在`defer`中执行

```go
package main

import "fmt"

func protect() {
    // defer + recover 是捕获 panic 的标准模式
    defer func() {
        // recover() 必须在 defer 内部调用
        if r := recover(); r != nil {
            // r 不是 nil，说明成功捕获了一个 panic
            fmt.Println("成功从 panic 中恢复！原因:", r)
        }
    }()

    // 调用可能会引发 panic 的函数
    mightPanic(0)

    // 这行代码不会被执行
    fmt.Println("这行代码不会被执行")
}

func mightPanic(x int) {
    if x == 0 {
        panic("这是一个自定义的 panic")
    }
    fmt.Println("函数正常执行")
}

func main() {
    fmt.Println("调用 protect() 函数")
    protect()
    fmt.Println("protect() 函数执行完毕，程序继续运行")
}  zhe
```


# 2. 方法

## 2.1 方法声明

方法就是绑定在struct上的，就相当于Java中的成员方法，定义的方式也很简单

```go
func (s structName) funcName(params) (result-list) {}
```

和函数的定义是一样的，只是在函数名称之间，加上是哪个struct就行，这个称之为『方法的接收器』

## 2.2 基于指针对象的方法

上面的对象，如果不使用指针的话，在函数调用的时候，其实就是一个对象的拷贝，比如
```go
func (s Student) modify() {
	s.Name = "zmg"   // ❌ ❌ ❌这个无效的，实际上没有修改原始的参数中的Name，因为这个s是实参的一份拷贝
}
```

那么，首先我们不推荐这样使用，如果结构体比较大的话，会带来拷贝的性能损耗，所以正常情况下都是使用指针对象来进行创建方法
除非结构体很小，而且是不可变的
```go
func (s *structName) funcName(params) (result-list) {}  // 指针的方式
```

那么在方法体中使用的时候，需要对指针进行`*`解构吗？ 答案是可以的，但是go简化了这个操作
- `(*s).Name = "zmg"`
- 简化的话，就直接`s.Name = "zmg"`  这个是底层来做的，但是不管怎样s肯定是一个指针，指向的是一块内存空间


# 3 接口

go中的接口设计，从我的判断来看，真的跟垃圾没啥区别，它是一种隐式的方式，让人特别抓狂

## 3.1 接口定义

注意： 不写func关键词
```go
// 定义接口
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}

// 组合接口
type ReadWriter interface {
    Reader
    Writer
}
```

## 3.2  隐式的实现接口

go中认为你只要给struct绑定的方法，恰巧和一个接口的方法签名一样，那么go就认为你实现了这个接口  ❓❓❓❓  WTF

```go
type File struct {
    name string
}

// File自动实现了Writer接口（只要有匹配的方法）
func (f *File) Write(data []byte) (int, error) {
    fmt.Printf("Writing %s to file %s\n", string(data), f.name)
    return len(data), nil
}

func main() {
    var w Writer = &File{name: "test.txt"}  // 此处为啥是指针，是因为上面实现的接收器是指针对象，所以这个整成指针就对了
    w.Write([]byte("hello"))
}
```

## 3.3 空接口

go中的空接口其实就是万能类型，是所有的类型天然的实现了空接口

```go
// 空接口可以存储任何类型的值
var anything interface{}

anything = 42
anything = "hello"
anything = []int{1, 2, 3}
anything = map[string]int{"key": 42}

// 更常见的写法（Go 1.18+）
var anything any = 42   // 这个any就对应的一个空接口
```

## 3.4 接口断言

一般来说，接口断言都是配合空接口使用

```go
func processValue(v interface{}) {
    // 类型断言
    if str, ok := v.(string); ok {
        fmt.Printf("Got string: %s\n", str)
    } else if num, ok := v.(int); ok {
        fmt.Printf("Got int: %d\n", num)
    }
}

// 类型开关
func processValueSwitch(v interface{}) {
    switch val := v.(type) {
    case string:
        fmt.Printf("String: %s\n", val)
    case int:
        fmt.Printf("Int: %d\n", val)
    case []int:
        fmt.Printf("Int slice: %v\n", val)
    default:
        fmt.Printf("Unknown type: %T\n", val)
    }
}
```

类型断言的语法是`x.(T)`  其中`x`就是接口类型的对象，`T`就是断言的可能的类型


接口的用处
- 隐式实现 - 无需显式声明实现关系
- 组合性 - 可以组合小接口形成大接口
- 多态性 - 同一接口可以有多种实现
- 测试友好 - 便于创建Mock对象
- 松耦合 - 降低代码间的依赖关系
 