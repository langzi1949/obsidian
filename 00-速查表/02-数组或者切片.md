
# 1. 初始化


```java title=java fold
// 固定大小数组
int[] arr1 = new int[5];
int[] arr2 = {1, 2, 3, 4, 5};
int[] arr3 = new int[]{1, 2, 3, 4, 5};

// 动态数组 ArrayList
ArrayList<Integer> list = new ArrayList<>();
ArrayList<Integer> list2 = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
```

```go title=go fold
// 数组（固定大小）
var arr1 [5]int
arr2 := [5]int{1, 2, 3, 4, 5}
arr3 := [...]int{1, 2, 3, 4, 5}

// 切片（动态）
slice1 := []int{}
slice2 := []int{1, 2, 3, 4, 5}
slice3 := make([]int, 5)      // 长度5
slice4 := make([]int, 5, 10)  // 长度5，容量10
```

```js title=javasript fold
const arr1 = new Array(5);
const arr2 = [1, 2, 3, 4, 5];
const arr3 = Array.from({length: 5}, (_, i) => i + 1);
const arr4 = Array.of(1, 2, 3, 4, 5);
```

```php title=php fold
$arr1 = array();
$arr2 = [1, 2, 3, 4, 5];
$arr3 = array(1, 2, 3, 4, 5);
$arr4 = array_fill(0, 5, 0);  // 5个元素，填充为0
```

```python title=python fold
arr1 = []
arr2 = [1, 2, 3, 4, 5]
arr3 = list(range(1, 6))
arr4 = [0] * 5  # 5个0
```

```groovy title=groovy fold
def arr1 = []
def arr2 = [1, 2, 3, 4, 5]
def arr3 = new ArrayList([1, 2, 3, 4, 5])
def arr4 = (1..5).toList()  // Range转列表
```

```kotlin title=kotlin fold
val arr1 = arrayOf(1, 2, 3, 4, 5)
val arr2 = intArrayOf(1, 2, 3, 4, 5)
val list1 = listOf(1, 2, 3, 4, 5)      // 不可变
val list2 = mutableListOf(1, 2, 3, 4, 5)  // 可变
```

```c title=c fold
#include <stdio.h>
#include <string.h>

int arr1[5];
int arr2[] = {1, 2, 3, 4, 5};
int arr3[5] = {1, 2, 3, 4, 5};
```

```cpp title=c++ fold
#include <vector>
#include <array>
#include <algorithm>

// C风格数组
int arr1[5];
int arr2[] = {1, 2, 3, 4, 5};

// std::array（固定大小）
std::array<int, 5> arr3 = {1, 2, 3, 4, 5};

// std::vector（动态）
std::vector<int> vec1;
std::vector<int> vec2 = {1, 2, 3, 4, 5};
std::vector<int> vec3(5, 10);  // 5个10
```

```dart title=dart fold
var arr1 = <int>[];
var arr2 = [1, 2, 3, 4, 5];
List<int> arr3 = List.filled(5, 0);      // 5个0
List<int> arr4 = List.generate(5, (i) => i + 1);
```

```scala title=scala fold
// Array（可变内容，固定大小）
val arr1 = Array(1, 2, 3, 4, 5)
val arr2 = Array.fill(5)(0)          // 5个0
val arr3 = Array.range(1, 6)         // 1到5
val arr4 = new Array[Int](5)         // 5个默认值

// List（不可变）
val list1 = List(1, 2, 3, 4, 5)
val list2 = (1 to 5).toList

// ArrayBuffer（可变大小）
import scala.collection.mutable.ArrayBuffer
val buffer = ArrayBuffer(1, 2, 3, 4, 5)
```

# 2. 填充和赋值


```java title=java fold
// 填充数组
Arrays.fill(arr1, 10); // 全部填充为10
Arrays.fill(arr1, 0, 3, 5); // 索引0-2填充为5

// 赋值
arr2[0] = 100;
list.add(6); // ArrayList追加
```

```go title=go fold
// 填充
for i := range arr1 {
    arr1[i] = 10
}

// 赋值
arr2[0] = 100
slice2[0] = 200
```

```js title=javasript fold
arr1.fill(10);           // 全部填充
arr1.fill(5, 0, 3);      // 索引0-2填充为5
arr2[0] = 100;           // 赋值
```

```php title=php fold
$arr1 = array_fill(0, 5, 10);  // 填充
$arr2[0] = 100;                 // 赋值
```

```python title=python fold
arr1 = [10] * 5         # 填充
arr2[0] = 100           # 赋值
```

```groovy title=groovy fold
def arr1 = [10] * 5         // 填充
arr2[0] = 100               // 赋值
```

```kotlin title=kotlin fold
val arr3 = IntArray(5) { 10 }      // 填充为10
arr2[0] = 100                       // 赋值
list2[0] = 200                      // 可变列表赋值
```

```c title=c fold
// 填充
memset(arr1, 0, sizeof(arr1));  // 填充为0  这个只能填充0， 填充其他的会得到奇怪的结果
for (int i = 0; i < 5; i++) {
    arr1[i] = 10;
}

// 赋值
arr2[0] = 100;
```

```cpp title=c++ fold
std::fill(arr1, arr1 + 5, 10);  // 填充
std::fill(vec2.begin(), vec2.end(), 10);
arr2[0] = 100;                   // 赋值
vec2[0] = 200;
```

```dart title=dart fold
arr3.fillRange(0, arr3.length, 10);  // 填充
arr2[0] = 100;                        // 赋值
```

```scala title=scala fold
// 填充
val arr5 = Array.fill(5)(10)         // 创建时填充
Array.tabulate(5)(i => i * 2)        // 根据索引填充

// 赋值
arr1(0) = 100                        // Array可以修改元素
buffer(0) = 200                      // ArrayBuffer可以修改
// list1(0) = 300  // 错误！List不可变
```

# 3. 长度


```java title=java fold
// 原生数组
int[] arr = {1, 2, 3, 4, 5};
int length = arr.length;  // 属性，不是方法

// ArrayList
ArrayList<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
int size = list.size();  // 方法调用
```

```go title=go fold
// 数组
arr := [5]int{1, 2, 3, 4, 5}
length1 := len(arr)

// 切片
slice := []int{1, 2, 3, 4, 5}
length2 := len(slice)

// 容量（仅切片）
capacity := cap(slice)
```

```js title=javasript fold
const arr = [1, 2, 3, 4, 5];
const length = arr.length;  // 属性
```

```php title=php fold
$arr = [1, 2, 3, 4, 5];

$length1 = count($arr);
$length2 = sizeof($arr);  // count的别名
```

```python title=python fold
arr = [1, 2, 3, 4, 5]
length = len(arr)  # 内置函数
```

```groovy title=groovy fold
def arr = [1, 2, 3, 4, 5]

def length1 = arr.size()    // 推荐
def length2 = arr.length    // 也可以
def length3 = arr.count()   // 也可以
```

```kotlin title=kotlin fold
// 原生数组
val arr = arrayOf(1, 2, 3, 4, 5)
val length1 = arr.size  // 属性

// List
val list = listOf(1, 2, 3, 4, 5)
val length2 = list.size  // 属性

// IntArray
val intArr = intArrayOf(1, 2, 3, 4, 5)
val length3 = intArr.size
```

```c title=c fold
#include <stdio.h>

int arr[] = {1, 2, 3, 4, 5};

// 方法1：sizeof计算（仅适用于栈上数组）
int length1 = sizeof(arr) / sizeof(arr[0]);

// 方法2：手动记录长度
int length2 = 5;

// 注意：传递给函数后数组会退化为指针，sizeof无法使用
void func(int arr[]) {
    // int len = sizeof(arr) / sizeof(arr[0]);  // 错误！
    // 需要单独传递长度参数
}

// 动态分配的数组必须手动记录长度
int *dynamic_arr = (int*)malloc(5 * sizeof(int));
int dynamic_length = 5;  // 必须手动记录
```

```cpp title=c++ fold
#include <vector>
#include <array>
#include <algorithm>

// C风格数组
int arr1[] = {1, 2, 3, 4, 5};
int length1 = sizeof(arr1) / sizeof(arr1[0]);

// std::array（C++11）
std::array<int, 5> arr2 = {1, 2, 3, 4, 5};
size_t length2 = arr2.size();

// std::vector
std::vector<int> vec = {1, 2, 3, 4, 5};
size_t length3 = vec.size();

// C++17: std::size
#include <iterator>
size_t length4 = std::size(arr1);
```

```dart title=dart fold
var arr = [1, 2, 3, 4, 5];
int length = arr.length;  // 属性
```

```scala title=scala fold
// Array
val arr = Array(1, 2, 3, 4, 5)
val length1 = arr.length  // 属性
val length2 = arr.size    // 方法（等同于length）

// List
val list = List(1, 2, 3, 4, 5)
val length3 = list.length
val length4 = list.size

// ArrayBuffer
import scala.collection.mutable.ArrayBuffer
val buffer = ArrayBuffer(1, 2, 3, 4, 5)
val length5 = buffer.length
val length6 = buffer.size
```

# 4. 包含


```java title=java fold
// 原生数组 - 需要手动遍历或使用工具类
int[] arr = {1, 2, 3, 4, 5};

// 方法1：Arrays工具类
boolean contains1 = Arrays.asList(arr).contains(3);  // 需要装箱

// 方法2：Stream API
boolean contains2 = Arrays.stream(arr).anyMatch(x -> x == 3);

// 方法3：手动遍历
boolean contains3 = false;
for (int val : arr) {
    if (val == 3) {
        contains3 = true;
        break;
    }
}

// ArrayList - 直接使用contains方法
ArrayList<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
boolean contains4 = list.contains(3);
```

```go title=go fold
// Go没有内置的contains方法，需要手动实现
slice := []int{1, 2, 3, 4, 5}

// 方法1：手动遍历
func contains(slice []int, target int) bool {
    for _, val := range slice {
        if val == target {
            return true
        }
    }
    return false
}

result := contains(slice, 3)  // true

// 方法2：使用sort.Search（仅适用于已排序数组）
import "sort"

sorted := []int{1, 2, 3, 4, 5}
index := sort.SearchInts(sorted, 3)
exists := index < len(sorted) && sorted[index] == 3

// 方法3：使用map作为set（适合频繁查询）
set := make(map[int]bool)
for _, val := range slice {
    set[val] = true
}
exists2 := set[3]  // true
```

```js title=javasript fold
const arr = [1, 2, 3, 4, 5];

// 方法1：includes（推荐，ES2016+）
const contains1 = arr.includes(3);  // true

// 方法2：indexOf（返回索引，-1表示不存在）
const contains2 = arr.indexOf(3) !== -1;  // true
const index = arr.indexOf(3);  // 2

// 方法3：find（返回元素本身）
const found = arr.find(x => x === 3);  // 3
const contains3 = found !== undefined;

// 方法4：some（返回布尔值）
const contains4 = arr.some(x => x === 3);  // true

// 方法5：findIndex（返回索引）
const foundIndex = arr.findIndex(x => x === 3);  // 2
const contains5 = foundIndex !== -1;
```

```php title=php fold
$arr = [1, 2, 3, 4, 5];

// 方法1：in_array（推荐）
$contains1 = in_array(3, $arr);  // true
$contains2 = in_array(3, $arr, true);  // 严格比较（类型也要相同）

// 方法2：array_search（返回键/索引）
$key = array_search(3, $arr);  // 2
$contains3 = $key !== false;

// 方法3：array_key_exists（检查键是否存在）
$contains4 = array_key_exists(2, $arr);  // true（索引2存在）

// 对于关联数组
$assoc = ['a' => 1, 'b' => 2, 'c' => 3];
$hasKey = array_key_exists('b', $assoc);  // true
$hasValue = in_array(2, $assoc);  // true
```

```python title=python fold
arr = [1, 2, 3, 4, 5]

# 方法1：in 操作符（推荐）
contains1 = 3 in arr  # True
contains2 = 6 not in arr  # True

# 方法2：count（返回出现次数）
count = arr.count(3)  # 1
contains3 = arr.count(3) > 0

# 方法3：index（返回索引，不存在会抛出异常）
try:
    index = arr.index(3)  # 2
    contains4 = True
except ValueError:
    contains4 = False

# 方法4：使用any（配合生成器）
contains5 = any(x == 3 for x in arr)  # True

# 对于集合（set）- 查找更快
arr_set = {1, 2, 3, 4, 5}
contains6 = 3 in arr_set  # O(1) 时间复杂度
```

```groovy title=groovy fold
def arr = [1, 2, 3, 4, 5]

// 方法1：contains（推荐）
def contains1 = arr.contains(3)  // true

// 方法2：in 操作符
def contains2 = 3 in arr  // true

// 方法3：find
def found = arr.find { it == 3 }  // 3
def contains3 = found != null

// 方法4：any
def contains4 = arr.any { it == 3 }  // true

// 方法5：indexOf
def index = arr.indexOf(3)  // 2
def contains5 = index != -1
```

```kotlin title=kotlin fold
val arr = arrayOf(1, 2, 3, 4, 5)
val list = listOf(1, 2, 3, 4, 5)

// 方法1：contains（推荐）
val contains1 = arr.contains(3)  // true
val contains2 = list.contains(3)  // true

// 方法2：in 操作符（最简洁）
val contains3 = 3 in arr  // true
val contains4 = 3 in list  // true
val contains5 = 6 !in arr  // true

// 方法3：any
val contains6 = arr.any { it == 3 }  // true

// 方法4：find
val found = arr.find { it == 3 }  // 3
val contains7 = found != null

// 方法5：indexOf
val index = arr.indexOf(3)  // 2
val contains8 = index != -1
```

```c title=c fold
#include <stdio.h>
#include <stdbool.h>

int arr[] = {1, 2, 3, 4, 5};
int length = sizeof(arr) / sizeof(arr[0]);

// 方法1：手动遍历
bool contains(int arr[], int length, int target) {
    for (int i = 0; i < length; i++) {
        if (arr[i] == target) {
            return true;
        }
    }
    return false;
}

bool result = contains(arr, length, 3);  // true

// 方法2：使用指针
bool contains_ptr(int *arr, int length, int target) {
    int *end = arr + length;
    for (int *ptr = arr; ptr < end; ptr++) {
        if (*ptr == target) {
            return true;
        }
    }
    return false;
}

// 方法3：二分查找（需要已排序且包含stdlib.h）
#include <stdlib.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

// 先排序
qsort(arr, length, sizeof(int), compare);

// 使用bsearch
int target = 3;
int *found = (int*)bsearch(&target, arr, length, sizeof(int), compare);
bool exists = (found != NULL);
```

```cpp title=c++ fold
#include <vector>
#include <algorithm>
#include <set>

std::vector<int> vec = {1, 2, 3, 4, 5};

// 方法1：std::find（推荐）
auto it = std::find(vec.begin(), vec.end(), 3);
bool contains1 = (it != vec.end());

// 方法2：std::count
int count = std::count(vec.begin(), vec.end(), 3);
bool contains2 = count > 0;

// 方法3：std::any_of
bool contains3 = std::any_of(vec.begin(), vec.end(), 
    [](int x) { return x == 3; });

// 方法4：std::binary_search（仅适用于已排序）
std::sort(vec.begin(), vec.end());
bool contains4 = std::binary_search(vec.begin(), vec.end(), 3);

// 方法5：使用set（适合频繁查询）
std::set<int> set = {1, 2, 3, 4, 5};
bool contains5 = set.find(3) != set.end();
bool contains6 = set.count(3) > 0;  // 更简洁

// C++20: std::ranges::find
#if __cplusplus >= 202002L
#include <ranges>
auto it2 = std::ranges::find(vec, 3);
bool contains7 = (it2 != vec.end());
#endif
```

```dart title=dart fold
var arr = [1, 2, 3, 4, 5];

// 方法1：contains（推荐）
bool contains1 = arr.contains(3);  // true

// 方法2：any
bool contains2 = arr.any((x) => x == 3);  // true

// 方法3：indexOf
int index = arr.indexOf(3);  // 2
bool contains3 = index != -1;

// 方法4：where + isNotEmpty
bool contains4 = arr.where((x) => x == 3).isNotEmpty;

// 方法5：firstWhere（会抛出异常如果不存在）
try {
  var found = arr.firstWhere((x) => x == 3);
  bool contains5 = true;
} catch (e) {
  bool contains5 = false;
}

// 使用orElse避免异常
var found = arr.firstWhere((x) => x == 3, orElse: () => null);
bool contains6 = found != null;

// 对于Set - 查找更快
var set = {1, 2, 3, 4, 5};
bool contains7 = set.contains(3);  // O(1) 时间复杂度
```

```scala title=scala fold
val arr = Array(1, 2, 3, 4, 5)
val list = List(1, 2, 3, 4, 5)

// 方法1：contains（推荐）
val contains1 = arr.contains(3)  // true
val contains2 = list.contains(3)  // true

// 方法2：exists
val contains3 = arr.exists(_ == 3)  // true
val contains4 = arr.exists(x => x == 3)  // true

// 方法3：find（返回Option）
val found = arr.find(_ == 3)  // Some(3)
val contains5 = found.isDefined
val contains6 = found.nonEmpty

// 方法4：indexOf
val index = arr.indexOf(3)  // 2
val contains7 = index != -1

// 方法5：indexWhere
val index2 = arr.indexWhere(_ == 3)  // 2
val contains8 = index2 != -1

// 方法6：count（返回出现次数）
val count = arr.count(_ == 3)  // 1
val contains9 = count > 0

// 对于Set - 查找更快
val set = Set(1, 2, 3, 4, 5)
val contains10 = set.contains(3)  // O(1) 时间复杂度
val contains11 = set(3)  // 更简洁的写法

// 使用模式匹配
found match {
  case Some(value) => println(s"Found: $value")
  case None => println("Not found")
}
```

# 5. 遍历数组


```java title=java fold
// for循环
for (int i = 0; i < arr2.length; i++) {
    System.out.println(arr2[i]);
}

// 增强for循环
for (int num : arr2) {
    System.out.println(num);
}

// Stream API
Arrays.stream(arr2).forEach(System.out::println);
```

```go title=go fold
// for循环
for i := 0; i < len(slice2); i++ {
    fmt.Println(slice2[i])
}

// range遍历
for index, value := range slice2 {
    fmt.Printf("Index: %d, Value: %d\n", index, value)
}

// 只遍历值
for _, value := range slice2 {
    fmt.Println(value)
}
```

```js title=javasript fold
// for循环
for (let i = 0; i < arr2.length; i++) {
    console.log(arr2[i]);
}

// forEach
arr2.forEach((val, index) => {
    console.log(val);
});

// for...of
for (const val of arr2) {
    console.log(val);
}
```

```php title=php fold
// for循环
for ($i = 0; $i < count($arr2); $i++) {
    echo $arr2[$i];
}

// foreach
foreach ($arr2 as $val) {
    echo $val;
}

// foreach with key
foreach ($arr2 as $key => $val) {
    echo "$key => $val";
}
```

```python title=python fold
# for循环（索引）
for i in range(len(arr2)):
    print(arr2[i])

# for循环（值）
for val in arr2:
    print(val)

# enumerate（索引和值）
for index, val in enumerate(arr2):
    print(f"{index}: {val}")
```

```groovy title=groovy fold
// each方法
arr2.each { println it }

// eachWithIndex
arr2.eachWithIndex { val, idx ->
    println "$idx: $val"
}

// for循环
for (val in arr2) {
    println val
}
```

```kotlin title=kotlin fold
// for循环
for (i in arr2.indices) {
    println(arr2[i])
}

// forEach
arr2.forEach { println(it) }

// forEachIndexed
arr2.forEachIndexed { index, value ->
    println("$index: $value")
}
```

```c title=c fold
int len = sizeof(arr2) / sizeof(arr2[0]);
for (int i = 0; i < len; i++) {
    printf("%d\n", arr2[i]);
}
```

```cpp title=c++ fold
// 传统for循环
for (int i = 0; i < vec2.size(); i++) {
    std::cout << vec2[i] << std::endl;
}

// 范围for循环（C++11）
for (const auto& val : vec2) {
    std::cout << val << std::endl;
}

// 迭代器
for (auto it = vec2.begin(); it != vec2.end(); ++it) {
    std::cout << *it << std::endl;
}

// for_each算法
std::for_each(vec2.begin(), vec2.end(), [](int val) {
    std::cout << val << std::endl;
});
```

```dart title=dart fold
// for循环
for (int i = 0; i < arr2.length; i++) {
  print(arr2[i]);
}

// forEach
arr2.forEach((val) {
  print(val);
});

// for-in
for (var val in arr2) {
  print(val);
}
```

```scala title=scala fold
// for循环（索引）
for (i <- arr1.indices) {
  println(arr1(i))
}

// for循环（值）
for (val <- arr1) {
  println(val)
}

// foreach方法
arr1.foreach(println)
arr1.foreach(x => println(x))

// zipWithIndex（获取索引和值）
arr1.zipWithIndex.foreach { case (val, idx) =>
  println(s"$idx: $val")
}
```

# 6. 追加元素


```java title=java fold
// 数组需要重新创建
int[] newArr = Arrays.copyOf(arr2, arr2.length + 1);
newArr[newArr.length - 1] = 6;

// ArrayList直接追加
list.add(7);
list.addAll(Arrays.asList(8, 9, 10));
```

```go title=go fold
slice2 = append(slice2, 6)
slice2 = append(slice2, 7, 8, 9)
slice2 = append(slice2, []int{10, 11}...)
```

```js title=javasript fold
arr2.push(6);              // 尾部追加单个
arr2.push(7, 8, 9);        // 尾部追加多个
arr2.unshift(0);           // 头部追加
```

```php title=php fold
$arr2[] = 6;                    // 尾部追加
array_push($arr2, 7, 8, 9);     // 尾部追加多个
array_unshift($arr2, 0);        // 头部追加
```

```python title=python fold
arr2.append(6)              # 追加单个
arr2.extend([7, 8, 9])      # 追加多个
arr2.insert(0, 0)           # 在索引0插入
```

```groovy title=groovy fold
arr2 << 6                   // 追加单个
arr2 += [7, 8, 9]           // 追加多个
arr2.add(10)                // add方法
```

```kotlin title=kotlin fold
// 数组是固定大小，需要转换为列表
list2.add(6)
list2.addAll(listOf(7, 8, 9))
```

```c title=c fold
// C语言数组大小固定，需要手动管理内存
// 示例：使用动态内存
#include <stdlib.h>

int *arr = (int*)malloc(5 * sizeof(int));
// 重新分配更大的内存
arr = (int*)realloc(arr, 6 * sizeof(int));
arr[5] = 6;
```

```cpp title=c++ fold
vec2.push_back(6);              // 尾部追加
vec2.insert(vec2.begin(), 0);   // 头部插入
vec2.insert(vec2.end(), {7, 8, 9});  // 尾部插入多个
```

```dart title=dart fold
arr2.add(6);                  // 追加单个
arr2.addAll([7, 8, 9]);       // 追加多个
arr2.insert(0, 0);            // 在索引0插入
```

```scala title=scala fold
// Array是固定大小，需要创建新数组
val arr6 = arr1 :+ 6                 // 尾部追加
val arr7 = 0 +: arr1                 // 头部追加
val arr8 = arr1 ++ Array(6, 7, 8)    // 追加多个

// ArrayBuffer可以直接追加
buffer += 6                          // 尾部追加单个
buffer += (7, 8, 9)                  // 尾部追加多个
buffer.append(10, 11)                // append方法
buffer.prepend(0)                    // 头部追加
buffer ++= ArrayBuffer(12, 13)       // 追加集合
```

# 7. 访问元素和修改元素


```java title=java fold
int val = arr2[0]; // 访问
arr2[0] = 99; // 修改

Integer val2 = list.get(0); // ArrayList访问
list.set(0, 88); // ArrayList修改
```

```go title=go fold
val := slice2[0]  // 访问
slice2[0] = 99    // 修改
```

```js title=javasript fold
const val = arr2[0];       // 访问
arr2[0] = 99;              // 修改
const last = arr2.at(-1);  // 访问最后一个元素
```

```php title=php fold
$val = $arr2[0];                // 访问
$arr2[0] = 99;                  // 修改
```

```python title=python fold
val = arr2[0]               # 访问
arr2[0] = 99                # 修改
last = arr2[-1]             # 访问最后一个元素
```

```groovy title=groovy fold
def val = arr2[0]           // 访问
arr2[0] = 99                // 修改
def last = arr2[-1]         // 访问最后一个元素
```

```kotlin title=kotlin fold
val val1 = arr2[0]          // 访问
arr2[0] = 99                // 修改
val last = arr2.last()      // 最后一个元素
```

```c title=c fold
int val = arr2[0];      // 访问
arr2[0] = 99;           // 修改
```

```cpp title=c++ fold
int val = vec2[0];              // 访问（不检查边界）
int val2 = vec2.at(0);          // 访问（检查边界）
vec2[0] = 99;                   // 修改
int last = vec2.back();         // 最后一个元素
```

```dart title=dart fold
var val = arr2[0];            // 访问
arr2[0] = 99;                 // 修改
var last = arr2.last;         // 最后一个元素
```

```scala title=scala fold
// 访问
val val1 = arr1(0)                   // 使用括号
val val2 = arr1.head                 // 第一个元素
val val3 = arr1.last                 // 最后一个元素
val val4 = arr1.apply(0)             // apply方法
val headOpt = arr1.headOption        // 安全访问，返回Option

// 修改
arr1(0) = 99                         // Array可以修改
arr1.update(0, 99)                   // update方法
buffer(0) = 88                       // ArrayBuffer可以修改
```

# 8. 数组过滤和转换


```java title=java fold
// 过滤 - Stream API
int[] filtered = Arrays.stream(arr2)
    .filter(x -> x > 2)
    .toArray();

// 转换（映射）
int[] doubled = Arrays.stream(arr2)
    .map(x -> x * 2)
    .toArray();
```

```go title=go fold
// 过滤
filtered := []int{}
for _, v := range slice2 {
    if v > 2 {
        filtered = append(filtered, v)
    }
}

// 转换（映射）
doubled := make([]int, len(slice2))
for i, v := range slice2 {
    doubled[i] = v * 2
}
```

```js title=javasript fold
// 过滤
const filtered = arr2.filter(x => x > 2);

// 转换（映射）
const doubled = arr2.map(x => x * 2);

// 链式操作
const result = arr2
    .filter(x => x > 2)
    .map(x => x * 2);
```

```php title=php fold
// 过滤
$filtered = array_filter($arr2, function($x) {
    return $x > 2;
});

// 转换（映射）
$doubled = array_map(function($x) {
    return $x * 2;
}, $arr2);
```

```python title=python fold
# 过滤
filtered = [x for x in arr2 if x > 2]
filtered2 = list(filter(lambda x: x > 2, arr2))

# 转换（映射）
doubled = [x * 2 for x in arr2]
doubled2 = list(map(lambda x: x * 2, arr2))
```

```groovy title=groovy fold
// 过滤
def filtered = arr2.findAll { it > 2 }

// 转换（映射）
def doubled = arr2.collect { it * 2 }
```

```kotlin title=kotlin fold
// 过滤
val filtered = arr2.filter { it > 2 }

// 转换（映射）
val doubled = arr2.map { it * 2 }

// 链式操作
val result = arr2.filter { it > 2 }.map { it * 2 }
```

```c title=c fold
// 过滤（手动实现）
int filtered[5];
int j = 0;
for (int i = 0; i < 5; i++) {
    if (arr2[i] > 2) {
        filtered[j++] = arr2[i];
    }
}

// 转换（手动实现）
int doubled[5];
for (int i = 0; i < 5; i++) {
    doubled[i] = arr2[i] * 2;
}
```

```cpp title=c++ fold
// 过滤
std::vector<int> filtered;
std::copy_if(vec2.begin(), vec2.end(), std::back_inserter(filtered),
    [](int x) { return x > 2; });

// 转换（映射）
std::vector<int> doubled(vec2.size());
std::transform(vec2.begin(), vec2.end(), doubled.begin(),
    [](int x) { return x * 2; });
```

```dart title=dart fold
// 过滤
var filtered = arr2.where((x) => x > 2).toList();

// 转换（映射）
var doubled = arr2.map((x) => x * 2).toList();

// 链式操作
var result = arr2.where((x) => x > 2).map((x) => x * 2).toList();
```

```scala title=scala fold
// 过滤
val filtered = arr1.filter(_ > 2)
val filtered2 = arr1.filterNot(_ <= 2)  // 反向过滤

// 转换（映射）
val doubled = arr1.map(_ * 2)
val mapped = arr1.map(x => x * x)

// flatMap（扁平化映射）
val flatMapped = arr1.flatMap(x => Array(x, x * 2))

// 链式操作
val result = arr1.filter(_ > 2).map(_ * 2)

// collect（部分函数）
val collected = arr1.collect {
  case x if x > 2 => x * 2
}
```

# 9. 数组分割和合并


```java title=java fold
// 分割
int[] slice = Arrays.copyOfRange(arr2, 1, 4); // 索引1到3

// 合并
int[] arr4 = {6, 7, 8};
int[] merged = new int[arr2.length + arr4.length];
System.arraycopy(arr2, 0, merged, 0, arr2.length);
System.arraycopy(arr4, 0, merged, arr2.length, arr4.length);
```

```go title=go fold
// 分割
slice := slice2[1:4] // 索引1到3

// 合并
slice3 := []int{6, 7, 8}
merged := append(slice2, slice3...)
```

```js title=javasript fold
// 分割
const slice = arr2.slice(1, 4);  // 索引1到3

// 合并
const arr5 = [6, 7, 8];
const merged1 = arr2.concat(arr5);
const merged2 = [...arr2, ...arr5];  // 扩展运算符
```

```php title=php fold
// 分割
$slice = array_slice($arr2, 1, 3);  // 从索引1开始，取3个元素

// 合并
$arr5 = [6, 7, 8];
$merged = array_merge($arr2, $arr5);
```

```python title=python fold
# 分割
slice1 = arr2[1:4]          # 索引1到3
slice2 = arr2[::2]          # 每隔一个元素

# 合并
arr5 = [6, 7, 8]
merged = arr2 + arr5
```

```groovy title=groovy fold
// 分割
def slice = arr2[1..3]      // 索引1到3

// 合并
def arr5 = [6, 7, 8]
def merged = arr2 + arr5
```

```kotlin title=kotlin fold
// 分割
val slice = arr2.slice(1..3)

// 合并
val arr5 = intArrayOf(6, 7, 8)
val merged = arr2 + arr5
```

```c title=c fold
// 分割
int slice[3];
memcpy(slice, arr2 + 1, 3 * sizeof(int));

// 合并
int arr4[] = {6, 7, 8};
int merged[8];
memcpy(merged, arr2, sizeof(arr2));
memcpy(merged + 5, arr4, sizeof(arr4));
```

```cpp title=c++ fold
// 分割
std::vector<int> slice(vec2.begin() + 1, vec2.begin() + 4);

// 合并
std::vector<int> vec3 = {6, 7, 8};
vec2.insert(vec2.end(), vec3.begin(), vec3.end());
```

```dart title=dart fold
// 分割
var slice = arr2.sublist(1, 4);  // 索引1到3

// 合并
var arr5 = [6, 7, 8];
var merged = [...arr2, ...arr5];
var merged2 = arr2 + arr5;
```

```scala title=scala fold
// 分割
val slice = arr1.slice(1, 4)         // 索引1到3
val (left, right) = arr1.splitAt(2)  // 在索引2处分割
val taken = arr1.take(3)             // 前3个元素
val dropped = arr1.drop(2)           // 跳过前2个元素
val takeWhile = arr1.takeWhile(_ < 4) // 从头取满足条件的元素
val dropWhile = arr1.dropWhile(_ < 3) // 从头跳过满足条件的元素

// 合并
val arr9 = Array(6, 7, 8)
val merged1 = arr1 ++ arr9           // 使用++
val merged2 = arr1.concat(arr9)      // concat方法
val merged3 = Array.concat(arr1, arr9) // Array伴生对象方法
```

# 10.  排序


```java title=java fold
Arrays.sort(arr2); // 升序
Arrays.sort(arr2, Collections.reverseOrder()); // 降序（需要Integer[]）
```

```go title=go fold
import "sort"

sort.Ints(slice2)                    // 升序
sort.Slice(slice2, func(i, j int) bool {
    return slice2[i] > slice2[j]     // 降序
})
```

```js title=javasript fold
arr2.sort((a, b) => a - b);      // 升序
arr2.sort((a, b) => b - a);      // 降序
```

```php title=php fold
sort($arr2);           // 升序
rsort($arr2);          // 降序
asort($arr2);          // 保持键值关联的升序
```

```python title=python fold
arr2.sort()                 # 原地升序
arr2.sort(reverse=True)     # 原地降序
sorted_arr = sorted(arr2)   # 返回新列表
```

```groovy title=groovy fold
arr2.sort()                 // 原地升序
def sorted = arr2.sort()    // 返回排序后的列表
def reversed = arr2.sort().reverse()  // 降序
```

```kotlin title=kotlin fold
arr2.sort()                 // 原地升序
val sorted = arr2.sorted()  // 返回新列表（升序）
val reversed = arr2.sortedDescending()  // 降序
```

```c title=c fold
#include <stdlib.h>

int compare(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);  // 升序
}

qsort(arr2, 5, sizeof(int), compare);
```

```cpp title=c++ fold
std::sort(vec2.begin(), vec2.end());              // 升序
std::sort(vec2.begin(), vec2.end(), std::greater<int>());  // 降序
```

```dart title=dart fold
arr2.sort();                         // 升序
arr2.sort((a, b) => b.compareTo(a)); // 降序
```

```scala title=scala fold
// 升序
val sorted1 = arr1.sorted            // 返回新数组
arr1.sortInPlace()                   // 原地排序（Array）
val sorted2 = arr1.sortWith(_ < _)   // 自定义比较

// 降序
val sorted3 = arr1.sorted.reverse
val sorted4 = arr1.sortWith(_ > _)

// 按自定义规则排序
val sorted5 = arr1.sortBy(x => -x)   // 按负值排序（降序）
```

# 11. 求和、最大值、最小值


```java title=java fold
int sum = Arrays.stream(arr2).sum();
int max = Arrays.stream(arr2).max().getAsInt();
int min = Arrays.stream(arr2).min().getAsInt();
```

```go title=go fold
// 求和
sum := 0
for _, v := range slice2 {
    sum += v
}

// 最大值
max := slice2[0]
for _, v := range slice2 {
    if v > max {
        max = v
    }
}

// 最小值
min := slice2[0]
for _, v := range slice2 {
    if v < min {
        min = v
    }
}
```

```js title=javasript fold
const sum = arr2.reduce((acc, val) => acc + val, 0);
const max = Math.max(...arr2);
const min = Math.min(...arr2);
```

```php title=php fold
$sum = array_sum($arr2);
$max = max($arr2);
$min = min($arr2);
```

```python title=python fold
total = sum(arr2)
maximum = max(arr2)
minimum = min(arr2)
```

```groovy title=groovy fold
def sum = arr2.sum()
def max = arr2.max()
def min = arr2.min()
```

```kotlin title=kotlin fold
val sum = arr2.sum()
val max = arr2.maxOrNull()
val min = arr2.minOrNull()
```

```c title=c fold
// 求和
int sum = 0;
for (int i = 0; i < 5; i++) {
    sum += arr2[i];
}

// 最大值
int max = arr2[0];
for (int i = 1; i < 5; i++) {
    if (arr2[i] > max) max = arr2[i];
}

// 最小值
int min = arr2[0];
for (int i = 1; i < 5; i++) {
    if (arr2[i] < min) min = arr2[i];
}
```

```cpp title=c++ fold
#include <numeric>

int sum = std::accumulate(vec2.begin(), vec2.end(), 0);
int max = *std::max_element(vec2.begin(), vec2.end());
int min = *std::min_element(vec2.begin(), vec2.end());
```

```dart title=dart fold
var sum = arr2.reduce((a, b) => a + b);
var max = arr2.reduce((a, b) => a > b ? a : b);
var min = arr2.reduce((a, b) => a < b ? a : b);

// 使用fold（更安全）
var sum2 = arr2.fold<int>(0, (prev, element) => prev + element);
```

```scala title=scala fold
// 求和
val sum1 = arr1.sum
val sum2 = arr1.reduce(_ + _)
val sum3 = arr1.fold(0)(_ + _)
val sum4 = arr1.foldLeft(0)(_ + _)

// 最大值和最小值
val max = arr1.max
val min = arr1.min

// 使用reduce（更灵活）
val max2 = arr1.reduce((a, b) => if (a > b) a else b)
val min2 = arr1.reduce((a, b) => if (a < b) a else b)

// 其他聚合操作
val product = arr1.product           // 乘积
val count = arr1.count(_ > 2)        // 计数满足条件的元素
val exists = arr1.exists(_ > 10)     // 是否存在满足条件的元素
val forall = arr1.forall(_ > 0)      // 是否全部满足条件
```
