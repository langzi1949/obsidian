从语法层面，PHP的类和接口的逻辑以及关键字，几乎跟Java一样，所以，本文就快速过一下

### 一、类的基本定义与实例化
类是对象的模板，通过 `class` 关键字定义，包含属性和方法；对象是类的实例。

#### 1. 定义类
```php
class Car {
    // 属性（类的变量，存储数据）
    public $color;
    private $speed = 0; // 私有属性，仅类内部可访问

    // 方法（类的函数，操作数据）
    public function start() {
        echo "汽车启动了";
    }

    // 带参数的方法
    public function setColor($color) {
        $this->color = $color; // $this 表示当前对象实例
    }
}
```

#### 2. 实例化对象
用 `new` 关键字创建类的实例（对象）：

```php
$myCar = new Car(); // 创建 Car 类的对象
$myCar->setColor("红色"); // 调用对象的方法
echo $myCar->color; // 访问公共属性（输出：红色）
$myCar->start(); // 调用方法（输出：汽车启动了）
```


### 二、类的属性
属性是类中存储数据的变量，有访问控制修饰符限制访问范围。
<span class="r">和Java不同，Java中不写控制符，默认是protected；但是PHP中是public</span>
#### 1. 访问控制修饰符
| 修饰符   | 访问范围                                  |
|----------|-------------------------------------------|
| `public` | 公开的，类内部、外部、子类都可访问        |
| `protected` | 受保护的，类内部和子类可访问，外部不可访问 |
| `private` | 私有的，仅类内部可访问                    |

示例：
```php
class Person {
    public $name;       // 公开属性
    protected $age;     // 受保护属性
    private $idCard;    // 私有属性

    // 类内部可访问所有属性
    public function setInfo($name, $age, $id) {
        $this->name = $name;
        $this->age = $age;
        $this->idCard = $id;
    }
}

$person = new Person();
$person->name = "张三"; // 合法（public）
$person->age = 25; // 错误（protected，外部不可访问）
```


#### 2. 静态属性
用 `static` 声明的属性，属于类本身而非对象，通过 `类名::属性名` 访问：
```php
class Counter {
    public static $count = 0;

    public function increment() {
        self::$count++; // self 表示当前类
    }
}

$c1 = new Counter();
$c1->increment();
$c2 = new Counter();
$c2->increment();

echo Counter::$count; // 输出：2（静态属性被所有对象共享）
```


### 三、类的方法
方法是类中定义的函数，用于操作属性或实现功能，也有访问控制修饰符。

#### 1. 普通方法
通过对象调用，可访问类的属性和其他方法：
```php
class Math {
    public function add($a, $b) {
        return $a + $b;
    }
}

$math = new Math();
echo $math->add(2, 3); // 输出：5
```


#### 2. 静态方法
用 `static` 声明的方法，属于类本身，通过 `类名::方法名` 调用，不能访问非静态属性：
```php
class Tool {
    public static function formatDate($timestamp) {
        return date('Y-m-d', $timestamp);
    }
}

// 无需实例化，直接调用
echo Tool::formatDate(time()); // 输出当前日期
```


#### 3. 构造方法与析构方法
- **构造方法**：`__construct()`，对象创建时自动调用，用于初始化对象。
- **析构方法**：`__destruct()`，对象销毁时自动调用，用于释放资源。

```php
class File {
    private $handle;

    // 构造方法：打开文件
    public function __construct($filename) {
        $this->handle = fopen($filename, 'r');
    }

    // 析构方法：关闭文件
    public function __destruct() {
        fclose($this->handle);
    }
}

$file = new File('test.txt'); // 自动调用 __construct()
unset($file); // 手动销毁对象，自动调用 __destruct()
```


### 四、类的继承
通过 `extends` 关键字实现继承，子类可复用父类的属性和方法，并可扩展或重写。

```php
// 父类
class Animal {
    protected $name;

    public function __construct($name) {
        $this->name = $name;
    }

    public function eat() {
        echo $this->name . "在吃东西";
    }
}

// 子类继承父类
class Dog extends Animal {
    // 重写父类方法
    public function eat() {
        echo $this->name . "在吃骨头";
    }

    // 子类新增方法
    public function bark() {
        echo $this->name . "在叫";
    }
}

$dog = new Dog("旺财");
$dog->eat(); // 输出：旺财在吃骨头（调用重写的方法）
$dog->bark(); // 输出：旺财在叫（子类新增方法）
```

**注意**：
- 子类不能访问父类的 `private` 属性/方法，但可访问 `protected` 和 `public`。
- 用 `parent::` 调用父类的方法（如 `parent::eat()`）。   ❗️❗️❗️ Java中是使用`super`


### 五、访问控制与封装
封装是 OOP 的三大特性之一（封装、继承、多态），通过访问修饰符隐藏内部实现，只暴露必要的接口。

示例：安全的属性访问（通过公共方法操作私有属性）
```php
class User {
    private $age; // 私有属性，外部不能直接修改

    // 公开方法：设置年龄（包含验证逻辑）
    public function setAge($age) {
        if ($age >= 0 && $age <= 120) {
            $this->age = $age;
        } else {
            throw new Exception("年龄不合法");
        }
    }

    // 公开方法：获取年龄
    public function getAge() {
        return $this->age;
    }
}

$user = new User();
$user->setAge(25); // 合法
echo $user->getAge(); // 输出：25
$user->age = 150; // 错误（私有属性，外部不可直接修改）
```


### 六、接口（Interface）
接口定义类的规范（必须实现哪些方法），用 `interface` 关键字，类通过 `implements` 实现接口。

```php
// 定义接口（只有方法声明，无实现）
interface Shape {
    public function getArea(); // 计算面积
    public function getPerimeter(); // 计算周长
}

// 实现接口（必须实现接口的所有方法）
class Circle implements Shape {
    private $radius;

    public function __construct($radius) {
        $this->radius = $radius;
    }

    public function getArea() {
        return 3.14 * $this->radius * $this->radius;
    }

    public function getPerimeter() {
        return 2 * 3.14 * $this->radius;
    }
}
```


### 七、📌 📌 📌 Trait
Trait 用于解决 PHP 单继承的限制，可在多个类中复用方法，用 `trait` 关键字定义。

```php
// 定义 trait
trait Loggable {
    public function log($msg) {
        echo "[" . date('Y-m-d H:i:s') . "] $msg";
    }
}

// 在类中使用 trait
class Order {
    use Loggable; // 引入 trait

    public function create() {
        $this->log("订单创建成功"); // 调用 trait 中的方法
    }
}

$order = new Order();
$order->create(); // 输出：[2023-09-12 15:30:00] 订单创建成功
```

需要注意：
- `trait` 必须在class结构体内进行`use`引用，他相当于代码块copy进来。
- 如果引入多个有重名的话，需要`insteadof`或者`as`起别名

```php
trait A { public function test() { echo "A"; } }
trait B { public function test() { echo "B"; } }

class MyClass {
    use A, B {
        A::test insteadof B; // 用 A 的 test() 替代 B 的
        B::test as testB; // 给 B 的 test() 起别名
    }
}

$obj = new MyClass();
$obj->test(); // 输出：A
$obj->testB(); // 输出：B
```

### 八. 引用其他类

通过`use`关键词，它类似java中的import，而且是如何找到类的，同样通过`namespace`找到的

```php
use App\Model\User as UserModel; // 取别名 UserModel
use App\Service\User as UserService;

// 通过别名使用，避免冲突
$user = new UserModel();
$service = new UserService();
```

这个APP是啥？ 其实是php自动加载的时候，起的一个别名。在`composer.json`文件中

```json
"autoload": {
        "psr-4": {
            "App\\": "app/",
        }
    },
```

那我们第三方的包，命名空间它是如何知道的呢？ 以laravel为例， 在`index.php`中，添加了这个
```php
require __DIR__.'/../vendor/autoload.php';
```

它就会自动加载相关的类， 通过`composer`安装的第三方包，他们是有一定的规范的，需要有namespace
等我们安装的时候，会把自动加载规则合并到项目的 vendor/composer/autoload_psr4.php 中，这样就能被`autoload.php`读取到了

至于本地的包或者自己开发的包，就直接该`composer.json`中自动引入的规则就行了

